<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="放一些笔记的地方"><meta name="keywords" content=""><meta name="author" content="木尘痕"><meta name="copyright" content="木尘痕"><title>一点浩然气 千里快哉风 | 风生之谷</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/muchenhen/muchenhen.github.io/master/xuange.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://github.com/muchenhen/muchenhen.github.io/blob/master/XuanGe.jpg?raw=true"></div><div class="author-info__name text-center">木尘痕</div><div class="author-info__description text-center">放一些笔记的地方</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">172</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://alec-ray.github.io/">止戈</a></div></div></div><nav id="nav" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">风生之谷</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">全部文章</a><a class="site-page" href="/tags">标签分类</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/contact">联系</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">风生之谷</div><div id="site-sub-title">一点浩然气 千里快哉风</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/27/stl%EF%BC%9Avector%E5%AE%B9%E5%99%A8/">STL：vector容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>是一个以线性顺序组织给定类型元素的容器。它支持对任何元素的快速随机访问，以及与序列之间的动态添加和删除。</p>
<p>可以利用索引随机访问</p>
<p>在尾部附加或者移除元素都很快速，但是在中段或起始安插元素比较费时，插入时后面的元素必须移动以保持相对位置</p>
<p><em>大部分情况元素追加式高速的，有时候可能是缓慢的，vector可能需要重新分配内存并将现有元素复制到对应位置</em></p>
<p>=====================================================</p>
<p><strong>底层原理</strong></p>
<p>底层是一个<strong>动态数组</strong>，包含三个迭代器：start和finish之间是已经被使用的空间范围，end_of_stroage是整块连续空间包括备用空间的尾部。</p>
<p><strong>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。</strong></p>
<p>当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。</p>
<p>因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。</p>
<p>头文件</p>
<p>#include<vector></p>
<p>声明元素类型为int的vector</p>
<p>vector<int> v1, v2, v3;</p>
<p>可以通过下标直接访问对应位置的元素</p>
<p>v1[0]</p>
<p><strong>vector<strong><strong>中</strong></strong>size<strong><strong>和</strong></strong>capacity****的区别</strong></p>
<p>size为当前容器中元素数量 finish - start</p>
<p>capacity为已经分配的内存可以容纳多少元素 end_of_storage - start</p>
<p><strong>vector****中的元素类型不能是引用</strong></p>
<p>vector 的底层实现要求连续的对象排列，引用不是对象，没有实际地址</p>
<p><strong>vector迭代器失效的情况</strong></p>
<p>当插入一个元素到vector中，由于重新引起了内存分配，指向原内存的迭代器会全部失效。</p>
<p>删除容器中一个元素后，该迭代器所指向的元素已经被删除，也会造成迭代器失效。erase方法会返回下一个有效的迭代器，所以在删除元素时需要</p>
<p>it=vec.erase(it);</p>
<p><strong>vector释放内存</strong></p>
<p>vec.clear()：清空内容，但是不释放内存。</p>
<p>vector<int>().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。</p>
<p>vec.shrink_to_fit()：请求容器降低其capacity和size匹配。</p>
<p>vec.clear(); vec.shrink_to_fit();：清空内容，且释放内存。</p>
<p><strong>vector常用函数</strong></p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-5.png" alt="2 
3 
4 
5 
6 
7 
8 
vector&lt;int&gt; 
vec . (c ,ø)); 
reverse(vec. begin() , vec . end()) 
sort (vec. begin() , vec . end()); 
vec . ; 
vec . size(); 
find (vec. begin() , vec . end() , 1); 
iterator = vec.erase(iterator) "></p>
<p>相关函数</p>
<p><strong>reserve</strong></p>
<p>为容器分配空间，直接扩充到已知大小，可以保证vector中的空间大小（capacity）最少达到参数所指定的大小</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-6.png" alt="C++ 
// vector_reserve. cpp 
// compile with: /EHsc 
#include 
#include &lt;iostream&gt; 
int main( ) 
using namespace std; 
vector &lt; int&gt; VI; 
//vector :iterator Iter; 
vl.push back( 1 ); 
cout &quot;Current capacity of VI 
VI. capacity( ) endl; 
VI. reserve( 28 ) ; 
cout &quot;Current capacity of VI 
VI. capacity( ) endl; 
Output 
Current capacity of VI 
Current capacity of VI "></p>
<p><strong>resize</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=vs-2019#resize">https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=vs-2019#resize</a></p>
<p>可以改变有效空间的大小</p>
<p>如果容器的大小小于请求的大小，则向向量添加元素，直到达到请求的大小。如果容器的大小大于请求的大小，则删除最靠近容器末端的元素，直到容器达到大小Newsize。如果容器的当前大小与请求的大小相同，则不采取任何操作。</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-7.png" alt="void resize(size_type Newsize); 
void resize(size_type Newsize, Type Val); "></p>
<p>esize函数<strong>重新分配</strong>大小，改变容器的大小，并且创建对象</p>
<p>当n小于当前size()值时候，vector首先会减少size()值 保存前n个元素，然后将超出n的元素删除(remove and destroy)</p>
<p>当n大于当前size()值时候，vector会插入相应数量的元素 使得size()值达到n，并对这些元素进行初始化，如果调用上面的第二个resize函数，指定val，vector会用val来初始化这些新插入的元素</p>
<p>当n大于capacity()值的时候，会自动分配重新分配内存存储空间。</p>
<p><strong>assign</strong></p>
<p>释放当前vector原来占用的空间并开辟新的空间</p>
<p>两个函数原型</p>
<p>void assign(size_type Count, const Type&amp; Val);</p>
<p>void assign(initializer_list<Type> IList);</p>
<p>template <class InputIterator> void assign(InputIterator First, InputIterator Last);</p>
<p>来自 &lt;<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=vs-2019#assign">https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=vs-2019#assign</a>&gt;</p>
<p>第一个相当于个拷贝函数，把first到last的值赋值给调用者；（注意区间的闭合）</p>
<p>第二个把n个x赋值给调用者；</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-8.png" alt="Copy 
/ vector _ assign . cpp 
// compile uith: /EHsc 
*include 
*include &lt;iostream&gt; 
int main() 
using namespace std; 
VI, v2, v3; 
vl.push back(1Ê); 
vl.push back(2Ê); 
vl.push back(3Ê); 
vl.push back(4Ê); 
vl.push back(SÊ); 
cout 
for (auto&amp; v : vl){ 
cout v 
cout endl; 
v2. assign(vl. begin() , 
cout 
for (auto&amp; v : v2){ 
cout v 
cout endl; 
v3.assign(7, 4); 
cout 
for (auto&amp; v : v3){ 
cout v 
cout endl; 
v3.assign({ S, 6, 7 
for (auto&amp; v : v3){ 
cout v 
cout endl; 
Vl. end())• "></p>
<p><strong>at</strong></p>
<p>返回参数中下标元素的引用。</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-11.png" alt="Example 
// vector _ at. cpp 
// compile with: /EHsc 
*include 
*include &lt;iostream&gt; 
int main( ) 
using namespace std; 
vector VI; 
VI. push back( 18 ); 
VI. 28 ); 
const int &amp;i 
vl.at( 8 
int &amp;j — 
cout 
cout 
Output 
vl.at( 1 ) ; 
&quot;The first element is 
&quot;The second element is &#39; 
i endl; 
j endl; 
Copy 
Copy 
The first element is le 
The second element is 28 "></p>
<p><strong>back</strong></p>
<p>返回向量的最后一个元素。如果向量为空，则返回值未定义。</p>
<p><strong>front</strong></p>
<p>返回指向向量对象中第一个元素的引用。如果向量为空，则返回未定义。</p>
<p>如果front的返回值被赋给一个const_reference，则不能修改vector对象。如果将front的返回值赋给引用，则可以修改vector对象。</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-9.png" alt="// vector _ front . cpp 
// compile with: /EHsc 
*include 
*include &lt;iostream&gt; 
int main( ) 
using namespace std; 
vector VI; 
VI. push back( 18 ); 
VI. 11 ) ; 
int&amp; i = vl.front( ); 
const int&amp; ii = vl.front( ); 
cout &quot;The first integer of VI is &quot;&lt;&lt; i endl; 
// by incrementing i, we move the front reference to the second element 
cout &quot;Now, the first integer of VI is i endl; "></p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-10.png" alt="Microsoft Visual Studio 
he first integer of VI is 10 
ow, the first integer of VI is 11 "></p>
<p>//通过增加i，我们将前面的引用移动到第二个元素</p>
<p><strong>erase</strong></p>
<p>将容器中的指定元素删除</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-13.png" alt="ras 
Removes an element or a range of elements in a vector from specified positions. 
iterator erase( 
const_iterator Where) ; 
iterator erase( 
const iterator first, 
const_iterator last) ; 
Parameters 
Where 
Position of the element to be removed from the vector. 
first 
Position of the first element removed from the vector. 
last 
Position just beyond the last element removed from the vector. "></p>
<p>![// vector erase. cpp<br>// compile uith: /EHsc<br>*include<br>*include <iostream><br>int main( )<br>using namespace std;<br>vector VI;<br>vector :iterator Iter;<br>vl.erase( Vl. begin( ) + 1,<br>vl . push<br>vl . push<br>vl . push<br>vl . push<br>vl . push<br>cout<br>back(<br>back(<br>back(<br>back(<br>back(<br>“VI<br>far ( Iter<br>cout<br>cout end];<br>vl.erase( Vl. begin( ) ) ;<br>cout “VI<br>far ( Iter<br>cout<br>cout endl;<br>cout “VI<br>far ( Iter<br>cout<br>18<br>28<br>3e<br>48 ) ;<br>Vl. begin( )<br>‘Iter;<br>Vl. begin( )<br>‘Iter;<br>Vl. begin( )<br>‘Iter;<br>Iter .<br>Iter .<br>vl.end( )<br>vl.end( )<br>vl.begin( )<br>vl.end( )<br>Iter<br>Iter++<br>Iter++<br>Iter++<br>cout<br>Output<br>1e<br>2e<br>2e<br>end];<br>2e 3e 48 sa<br>3e 4e sa<br>se ](<a target="_blank" rel="noopener" href="http://www.muchenhen.com/wp-content/uploads/2019/10/image-12.png">http://www.muchenhen.com/wp-content/uploads/2019/10/image-12.png</a>)</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/27/stl%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/">STL序列式容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p><strong>vector：</strong>可变大小数组；支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢</p>
<p><strong>deque：</strong>双端队列；支持快速随机访问，在头尾插入/删除速度很快</p>
<p><strong>list：</strong>双向链表；只支持双向顺序访问，在list任何位置插入/删除速度很快</p>
<p><strong>forward_list：</strong>单向链表；单向链表，只支持单向顺序访问，在任何位置插入删除都很快</p>
<p><strong>array</strong>：固定大小数组；支持快速随机访问，不能添加或者删除元素</p>
<p><strong>string</strong>：与vector相似的容器，但专门用于保存字符。随机访问快，在尾位置插入删除快</p>
<p><strong>容器选择</strong></p>
<p><strong>什么情况下用<strong><strong>vector</strong></strong>，什么情况下用<strong><strong>list</strong></strong>，什么情况下用****deque</strong></p>
<p>vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。</p>
<p>list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。</p>
<p>需要从首尾两端进行插入或删除操作的时候需要选择deque。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/27/c11-stl%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/">C++11 STL中的容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>=====================================================</p>
<p><strong>一、顺序</strong>容器：</p>
<p><strong>vector：</strong>可变大小数组；支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢</p>
<p><strong>deque：</strong>双端队列；支持快速随机访问，在头尾插入/删除速度很快</p>
<p><strong>list：</strong>双向链表；只支持双向顺序访问，在list任何位置插入/删除速度很快</p>
<p><strong>forward_list：</strong>单向链表；单向链表，只支持单向顺序访问，在任何位置插入删除都很快</p>
<p><strong>array</strong>：固定大小数组；支持快速随机访问，不能添加或者删除元素</p>
<p><strong>string</strong>：与vector相似的容器，但专门用于保存字符。随机访问快，在尾位置插入删除快</p>
<p>==================================================</p>
<p><strong>二、关联</strong>容器：</p>
<p>按<strong>关键字有序</strong>保存元素：（底层实现为<strong>红黑树</strong>）</p>
<p><strong>map：</strong>关联数组；保存关键字-值对；</p>
<p><strong>set：</strong>关键字即值，即只保存关键字的容器；</p>
<p><strong>multimap：</strong>关键字可重复的map；</p>
<p><strong>multiset：</strong>关键字可重复的set；</p>
<p>-——————————————————————————-</p>
<p><strong>无序</strong>集合：</p>
<p><strong>unordered_map：</strong>用哈希函数组织的map；</p>
<p><strong>unordered_set：</strong>用哈希函数组织的set；</p>
<p><strong>unordered_multimap：</strong>哈希组织的map；关键字可以重复出现；</p>
<p><strong>unordered_multiset：</strong>哈希组织的set；关键字可以重复出现。</p>
<p>==================================================</p>
<p>三、其他项：</p>
<p><strong>stack、queue、valarray、bitset</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/27/dx12%E9%BE%99%E4%B9%A6part%E2%85%A0chapter-1-%E5%90%91%E9%87%8F/">DX12龙书PartⅠChapter 1 向量</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/DirectX12/">DirectX12</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a></span><div class="content"><p>目的:</p>
<ul>
<li>  1. 学习向量是如何用几何和数字表示的。</li>
<li>  2. 发现向量上定义的运算及其几何应用。</li>
<li>  3.熟悉DirectXMath类库中的向量函数和类。</li>
</ul>
<p>D3D使用左手坐标系</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image.png" alt="zł "></p>
<p><strong>1.6 DIRECTX MATH VECTORS</strong><br><strong>D3D数学向量</strong></p>
<p>要使用d3d数学库，需要</p>
<p>#include &lt;DirectXMath.h&gt;<br>#include &lt;DirectXPackedVector.h&gt;</p>
<p>命名空间</p>
<p>DirectX<br>DirectX::PackedVector</p>
<p><strong>XMVECTOR</strong></p>
<p>库中核心的Vector类型，是对SIMD寄存器的映射。当前CPU是SSE2指令集可以使用时如下定义：</p>
<p>typedef _m128 XMVECTOR;</p>
<p>_m128是由Microsoft提供的基本数据类型，用于与SSE、SSE2内部指令一起使用的。在16字节边界上自动对齐。ARM处理器不支持该类型。<br>虽然这是一个128位宽的寄存器，能存储一个四维的Vector，但当我们使用二维或三维的Vector运算时，为了效率，仍然会去使用XMVECTOR类型。<br>XMVECTOR的数据不能直接访问。可以转换成XMFLOAT类型（转换方法见下文），也可通过特定的接口get或set其某个分量：</p>
<p><strong>加载和存储方法</strong></p>
<p>We use the following methods to load data from XMFLOATn into XMVECTOR:<br>使用如下的方法去加载数据，从XMFLOAT到XMVECTOR</p>
<p>// Loads XMFLOAT2 into XMVECTOR<br>//加载2到V<br><strong>XMVECTOR XM_CALLCONV XMLoadFloat2(const XMFLOAT2* pSource);</strong></p>
<p>// Loads XMFLOAT3 into XMVECTOR<br><strong>XMVECTOR XM_CALLCONV XMLoadFloat3(const XMFLOAT3* pSource);</strong></p>
<p>// Loads XMFLOAT4 into XMVECTOR<br><strong>XMVECTOR XM_CALLCONV XMLoadFloat4(const XMFLOAT4* pSource);</strong></p>
<p> We use the following methods to store data from XMVECTOR into XMFLOATn:<br>使用下面的方法存储数据，从V到F</p>
<p>// Loads XMVECTOR into XMFLOAT2<br><strong>void XM_CALLCONV XMStoreFloat2(XMFLOAT2 *pDestination, FXMVECTOR V);</strong></p>
<p>// Loads XMVECTOR into XMFLOAT3<br><strong>void XM_CALLCONV XMStoreFloat3(XMFLOAT3 *pDestination, FXMVECTOR V);</strong></p>
<p>// Loads XMVECTOR into XMFLOAT4<br><strong>void XM_CALLCONV XMStoreFloat4(XMFLOAT4 *pDestination, FXMVECTOR V);</strong></p>
<p>Sometimes we just want to get or set one component of an XMVECTOR; the following getter and setter functions facilitate this:<br>获得向量的某个组件，get方法</p>
<p>float XM_CALLCONV XMVectorGetX(FXMVECTOR V);</p>
<p>float XM_CALLCONV XMVectorGetY(FXMVECTOR V);</p>
<p> float XM_CALLCONV XMVectorGetZ(FXMVECTOR V);</p>
<p> float XM_CALLCONV XMVectorGetW(FXMVECTOR V);</p>
<p>设置向量的某个组件，set方法</p>
<p>XMVECTOR XM_CALLCONV XMVectorSetX(FXMVECTOR V, float x);</p>
<p> XMVECTOR XM_CALLCONV XMVectorSetY(FXMVECTOR V, float y);</p>
<p>XMVECTOR XM_CALLCONV XMVectorSetZ(FXMVECTOR V, float z);</p>
<p>XMVECTOR XM_CALLCONV XMVectorSetW(FXMVECTOR V, float w);</p>
<p>XMVECTOR重载了加减乘除等运算符，可以方便的进行运算。</p>
<p><strong>1.6.3 参数传递</strong></p>
<p>由于XMVECTOR的数据存储在寄存器，而不在堆栈上，因此参数传递时会有些特殊。基本的想法是，能用寄存器传递的就用寄存器传递，不能的就用栈。具体可以通过寄存器传递的参数数量，根据平台和编译器而定。<br>为此，增加了几种用于参数传递的数据类型，FXMVECTOR、GXMVECTOR、HXMVECTOR、CXMVECTOR。基本的使用规则是：</p>
<ol>
<li> 前三个XMVECTOR参数使用FXMVECTOR</li>
<li> 第四个XMVECTOR参数使用GXMVECTOR</li>
<li> 第五六个XMVECTOR参数使用HXMVECTOR</li>
<li> 其他使用CXMVECTOR</li>
</ol>
<p>而宏XM_CALLCONV，就是用于告诉编译器该函数调用时，有这种特别的参数传递规则。<br>有这样的定义</p>
<p>void XM_CALLCONV XMStoreFloat2(XMFLOAT2 *pDestination, FXMVECTOR V);</p>
<p>但是，这些规则在构造函数中并不适用。在构造函数中：</p>
<ol>
<li> 前三个XMVECTOR参数使用FXMVECTOR</li>
<li> 其他使用CXMVECTOR</li>
<li> 不要使用XM_CALLCONV</li>
</ol>
<p>另外，这些规则只是针对于XMVECTOR类型本身。而对于复合类，XMVECTOR&amp;、XMVECTOR*并不会使用寄存器传递，和普通参数同等看待。</p>
<p><strong>1.6.5重载运算符</strong></p>
<p>XMVECTOR有几个重载的运算符，用于执行向量的加法、减法和标量乘法。</p>
<p>XMVECTOR XM_CALLCONV operator+ (FXMVECTOR V);</p>
<p>XMVECTOR XM_CALLCONV operator- (FXMVECTOR V);</p>
<p>XMVECTOR&amp; XM_CALLCONV operator+= (XMVECTOR&amp; V1, FXMVECTOR V2);</p>
<p> XMVECTOR&amp; XM_CALLCONV operator-= (XMVECTOR&amp; V1, FXMVECTOR V2);</p>
<p>XMVECTOR&amp; XM_CALLCONV operator*= (XMVECTOR&amp; V1, FXMVECTOR V2);</p>
<p>XMVECTOR&amp; XM_CALLCONV operator/= (XMVECTOR&amp; V1, FXMVECTOR V2);</p>
<p>XMVECTOR&amp; operator*= (XMVECTOR&amp; V, float S);</p>
<p> XMVECTOR&amp; operator/= (XMVECTOR&amp; V, float S);</p>
<p>XMVECTOR XM_CALLCONV operator+ (FXMVECTOR V1, FXMVECTOR V2);</p>
<p>XMVECTOR XM_CALLCONV operator- (FXMVECTOR V1, FXMVECTOR V2);</p>
<p> XMVECTOR XM_CALLCONV operator* (FXMVECTOR V1, FXMVECTOR V2);</p>
<p>XMVECTOR XM_CALLCONV operator/ (FXMVECTOR V1, FXMVECTOR V2);</p>
<p> XMVECTOR XM_CALLCONV operator* (FXMVECTOR V, float S);</p>
<p> XMVECTOR XM_CALLCONV operator* (float S, FXMVECTOR V);</p>
<p>XMVECTOR XM_CALLCONV operator/ (FXMVECTOR V, float S);</p>
<p><strong>1.6.6其他参数</strong></p>
<p><strong>定义以下常量用于涉及π近似不同的表达式</strong><strong>:</strong></p>
<p>const float XM_PI = 3.141592654f;</p>
<p>const float XM_2PI = 6.283185307f;</p>
<p>const float XM_1DIVPI = 0.318309886f;</p>
<p>const float XM_1DIV2PI = 0.159154943f;</p>
<p>const float XM_PIDIV2 = 1.570796327f;</p>
<p>const float XM_PIDIV4 = 0.785398163f;</p>
<p><strong>弧度和角度转换的内联函数：</strong></p>
<p>inline float XMConvertToRadians(float fDegrees) { return fDegrees * (XM_PI / 180.0f); } inline float XMConvertToDegrees(float fRadians) { return fRadians * (180.0f / XM_PI); }</p>
<p><strong>min</strong><strong>/max****函数：</strong></p>
<p>template<class T> inline T XMMin(T a, T b) { return (a &lt; b) ? a : b; }</p>
<p>template<class T> inline T XMMax(T a, T b) { return (a &gt; b) ? a : b; }</p>
<p><strong>1.6.7 Setter 函数</strong></p>
<p>DirectX Math提供了以下函数来设置XMVECTOR的内容:</p>
<p>// Returns the zero vector 0  置0</p>
<p>XMVECTOR XM_CALLCONV XMVectorZero();</p>
<p>// Returns the vector (1, 1, 1, 1)  置1</p>
<p>XMVECTOR XM_CALLCONV XMVectorSplatOne();</p>
<p>// Returns the vector (x, y, z, w)</p>
<p>XMVECTOR XM_CALLCONV XMVectorSet(float x, float y, float z, float w);</p>
<p>// Returns the vector (s, s, s, s)</p>
<p>XMVECTOR XM_CALLCONV XMVectorReplicate(float Value);</p>
<p>// Returns the vector (vx, vx, vx, vx)</p>
<p>XMVECTOR XM_CALLCONV XMVectorSplatX(FXMVECTOR V);</p>
<p>// Returns the vector (vy, vy, vy, vy)</p>
<p>XMVECTOR XM_CALLCONV XMVectorSplatY(FXMVECTOR V);</p>
<p>// Returns the vector (vz, vz, vz, vz)</p>
<p>XMVECTOR XM_CALLCONV XMVectorSplatZ(FXMVECTOR V);</p>
<p><strong>1.6.8向量函数</strong></p>
<p>DirectX Math提供以下函数来执行各种向量操作。用3D版本来说明，但也有类似的2D和4D版本;2D和4D版本的名称与3D版本相同，只是分别用2和4代替了3。</p>
<p>XMVECTOR XM_CALLCONV XMVector3Length( // Returns ||v||</p>
<p>FXMVECTOR V); // Input v</p>
<p>XMVECTOR XM_CALLCONV XMVector3LengthSq( // Returns ||v||2</p>
<p>FXMVECTOR V); // Input v</p>
<p>XMVECTOR XM_CALLCONV XMVector3Dot( // Returns v1·v2</p>
<p>FXMVECTOR V1, // Input v1</p>
<p>FXMVECTOR V2); // Input v2</p>
<p>XMVECTOR XM_CALLCONV XMVector3Cross( // Returns v1 × v2</p>
<p>FXMVECTOR V1, // Input v1</p>
<p>FXMVECTOR V2); // Input v2</p>
<p>XMVECTOR XM_CALLCONV XMVector3Normalize( // Returns</p>
<p>v/||v|| FXMVECTOR V); // Input v</p>
<p>XMVECTOR XM_CALLCONV XMVector3Orthogonal( // Returns a</p>
<p>vector orthogonal to v FXMVECTOR V); // Input v</p>
<p> XMVECTOR XM_CALLCONV</p>
<p>XMVector3AngleBetweenVectors( // Returns the angle between v1 and</p>
<p>v2</p>
<p>FXMVECTOR V1, // Input v1</p>
<p>FXMVECTOR V2); // Input v2</p>
<p> void XM_CALLCONV XMVector3ComponentsFromNormal(</p>
<p>XMVECTOR* pParallel, // Returns projn(v)</p>
<p>XMVECTOR* pPerpendicular, // Returns perpn(v)</p>
<p>FXMVECTOR V, // Input v</p>
<p>FXMVECTOR Normal); // Input n</p>
<p>bool XM_CALLCONV XMVector3Equal( // Returns v1 = v2</p>
<p>FXMVECTOR V1, // Input v1</p>
<p>FXMVECTOR V2); // Input v2</p>
<p> bool XM_CALLCONV XMVector3NotEqual( // Returns v1 ≠ v2</p>
<p>FXMVECTOR V1, // Input v1</p>
<p>FXMVECTOR V2); // Input v2</p>
<p><strong>Sample</strong> Code:</p>
<p>#include  // for XMVerifyCPUSupport<br>#include<br>#include<br>#include<br>using namespace std;<br>using namespace DirectX;<br>using namespace DirectX::PackedVector;</p>
<p>// Overload the  “&lt;&lt;” operators so that we can use cout to<br>// output XMVECTOR objects.</p>
<p>//重载流运算符<br>ostream&amp; XM_CALLCONV operator &lt;&lt; (ostream&amp; os, FXMVECTOR v)<br>{<br>    XMFLOAT3 dest;<br>    XMStoreFloat3(&amp;dest, v);</p>
<pre><code>os &lt;&lt; &quot;(&quot; &lt;&lt; dest.x &lt;&lt; &quot;, &quot; &lt;&lt; dest.y &lt;&lt; &quot;, &quot; &lt;&lt; dest.z &lt;&lt; &quot;)&quot;;
return os;
</code></pre>
<p>}</p>
<p>int main()<br>{<br>    cout.setf(ios_base::boolalpha);</p>
<pre><code>// Check support for SSE2 (Pentium4, AMD K8, and above).
//检查是否支持SSE2

if (!XMVerifyCPUSupport())
&#123;
    cout &lt;&lt; &quot;directx math not supported&quot; &lt;&lt; endl;
    return 0;
&#125;

XMVECTOR n = XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f);
XMVECTOR u = XMVectorSet(1.0f, 2.0f, 3.0f, 0.0f);
XMVECTOR v = XMVectorSet(-2.0f, 1.0f, -3.0f, 0.0f);
XMVECTOR w = XMVectorSet(0.707f, 0.707f, 0.0f, 0.0f);

// Vector addition: XMVECTOR operator + 
// 向量加法
XMVECTOR a = u + v;

// Vector subtraction: XMVECTOR operator - 
// 向量减法
XMVECTOR b = u - v;

// Scalar multiplication: XMVECTOR operator \* 
// 数乘
XMVECTOR c = 10.0f\*u;

// ||u||
// 向量的模
XMVECTOR L = XMVector3Length(u);

// d = u / ||u||
// 向量单位化
XMVECTOR d = XMVector3Normalize(u);

// s = u dot v
// 点乘
XMVECTOR s = XMVector3Dot(u, v);

// e = u x v
// 叉乘
XMVECTOR e = XMVector3Cross(u, v);

// Find proj\_n(w) and perp\_n(w)
// w对于n的两个投影分量
XMVECTOR projW;
XMVECTOR perpW;
XMVector3ComponentsFromNormal(&amp;projW, &amp;perpW, w, n);

// Does projW + perpW == w?
// 两个投影分量对应的向量，加法结果是原向量，三角形法则
bool equal = XMVector3Equal(projW + perpW, w) != 0;
bool notEqual = XMVector3NotEqual(projW + perpW, w) != 0;

// The angle between projW and perpW should be 90 degrees.
// 两个投影分量是垂直的
XMVECTOR angleVec = XMVector3AngleBetweenVectors(projW, perpW);
float angleRadians = XMVectorGetX(angleVec);
float angleDegrees = XMConvertToDegrees(angleRadians);

cout &lt;&lt; &quot;u                   = &quot; &lt;&lt; u &lt;&lt; endl;
cout &lt;&lt; &quot;v                   = &quot; &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; &quot;w                   = &quot; &lt;&lt; w &lt;&lt; endl;
cout &lt;&lt; &quot;n                   = &quot; &lt;&lt; n &lt;&lt; endl;
cout &lt;&lt; &quot;a = u + v           = &quot; &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; &quot;b = u - v           = &quot; &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; &quot;c = 10 \* u          = &quot; &lt;&lt; c &lt;&lt; endl;
cout &lt;&lt; &quot;d = u / ||u||       = &quot; &lt;&lt; d &lt;&lt; endl;
cout &lt;&lt; &quot;e = u x v           = &quot; &lt;&lt; e &lt;&lt; endl;
cout &lt;&lt; &quot;L  = ||u||          = &quot; &lt;&lt; L &lt;&lt; endl;
cout &lt;&lt; &quot;s = u.v             = &quot; &lt;&lt; s &lt;&lt; endl;
cout &lt;&lt; &quot;projW               = &quot; &lt;&lt; projW &lt;&lt; endl;
cout &lt;&lt; &quot;perpW               = &quot; &lt;&lt; perpW &lt;&lt; endl;
cout &lt;&lt; &quot;projW + perpW == w  = &quot; &lt;&lt; equal &lt;&lt; endl;
cout &lt;&lt; &quot;projW + perpW != w  = &quot; &lt;&lt; notEqual &lt;&lt; endl;
cout &lt;&lt; &quot;angle               = &quot; &lt;&lt; angleDegrees &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-3.png" alt="0) 
10 * u 
=(1,2,3) 
(-2, 1, -3) 
(0. 707, 0. 707, 
(10, 20, 30) 
d = u 
u 
rajW 
erpW 
rajW 
rajW 
angle 
/IIuII 
V 
perpW 
perpW 
(0. 267261, 0. 534522, 0. 801784) 
(-9, -3, 5) 
(3. 74166, 3. 74166, 3. 74166) 
(0. 707, 0, 0) 
(0, 0. 707, 0) 
false "></p>
<p>总结：</p>
<p>1. 对局部或全局变量使用XMVECTOR。<br>2. 对类数据成员使用XMFLOAT2、XMFLOAT3和XMFLOAT4。<br>3.在进行计算之前，使用加载函数将XMFLOATn转换为XMVECTOR<br>4. 使用XMVECTOR实例进行计算。<br>5. 使用存储函数将XMVECTOR转换为XMFLOATn</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/image-1.png" alt="I. 
2. 
3. 
4. 
5. 
Use XMVECTOR for local or global variables. 
Use XMFLOAT2, XMFLOAT3, and XMFLOAT4 for class data members. 
Use loading functions to convert from XMFLOATn to XMVECTOR before 
doing calculations. 
Do calculations with XMVECTOR instances. 
Use storage functions to convert from XMVECTOR to XMFLOATn. "></p>
<p>矢量用于模拟同时具有大小和方向的物理量。几何上，我们用有向线段表示一个向量。矢量平行于自身平移时处于标准位置，使其尾部与坐标系的原点重合。一个处于标准位置的向量可以通过指定其头部相对于一个坐标系的坐标来进行数值描述。</p>
<p>![operations: </p>
<ol>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Addition: u + V = (ux + vx, uy + vy, Liz + vz)<br>Subtraction: u — V = (ux — vx, uy — vy, Liz — vz)<br>Scalar Multiplication: ku = (ku ku kuz)<br>x2 + + z2<br>Length: Ilu<br>Normalization:<br>Dot Product:<br>Cross Product:<br>(xyz<br>I lull ‘ llull ‘ lull<br>Ilull<br>uv<br>—uV u V —uyvx) ](<a target="_blank" rel="noopener" href="http://www.muchenhen.com/wp-content/uploads/2019/10/image-2.png">http://www.muchenhen.com/wp-content/uploads/2019/10/image-2.png</a>)</li>
</ol>
<p>提供了以下有用的函数来计算一个向量的长度，一个向量的长度的平方，计算两个向量的点积，计算两个向量的外积，以及对一个向量进行归一化:</p>
<p>XMVECTOR XM_CALLCONV XMVector3Length(FXMVECTOR V);</p>
<p>XMVECTOR XM_CALLCONV XMVector3LengthSq(FXMVECTOR V);</p>
<p>XMVECTOR XM_CALLCONV XMVector3Dot(FXMVECTOR V1, FXMVECTOR V2);</p>
<p>XMVECTOR XM_CALLCONV XMVector3Cross(FXMVECTOR V1, FXMVECTOR V2);</p>
<p>XMVECTOR XM_CALLCONV XMVector3Normalize(FXMVECTOR V);</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/27/dx12%E9%BE%99%E4%B9%A6part%E2%85%A0chapter-0-dx%E6%95%B0%E5%AD%A6%E5%BA%93/">DX12龙书PartⅠChapter 0 DX数学库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/DirectX12/">DirectX12</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a></span><div class="content"><p>DirectX Math Library 是一个3D数学库，包含在Windows SDK中。</p>
<p>该库使用了SSE2（Streaming SIMD Extensions 2）指令集。使用128位宽的SIMD（Single Instruction Multiple Data）寄存器，因此做向量计算会更快。</p>
<p>注：在X86平台下，需要在VS中手动设置，启用SSE2（Enable Enhanced Instruction Set）。在任何平台下，都要手动启用fast floating point model。在project prote具体方法请查阅资料。</p>
<p>在VS2019中的Win32默认为启动的。</p>
<p>关于检查自己的硬件是否支持可以在main函数中添加如下代码：</p>
<p> if (!XMVerifyCPUSupport())<br>    {<br>        cout &lt;&lt; “directx math not supported” &lt;&lt; endl;<br>        return 0;<br>    }</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/21/%E3%80%90unity%E4%BC%98%E5%8C%96%E3%80%91profiler%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8/">【Unity优化】Profiler性能分析器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/">unity3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/Unity%E4%BC%98%E5%8C%96/">Unity优化</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Unity学习笔记</a></span><div class="content"><p><strong>【Unity优化】Profiler性能分析器</strong> <strong>【总结，来自Unity Documentation】</strong> <strong>本文导图：</strong> [caption id=”attachment_1204” align=”aligncenter” width=”3863”]<a target="_blank" rel="noopener" href="http://www.muchenhen.com/wp-content/uploads/2019/03/UnityProfiler.png"><img src="http://www.muchenhen.com/wp-content/uploads/2019/03/UnityProfiler.png" alt="点击查看原图"></a> 点击查看原图[/caption] **Profiler概述 ** Profiler窗口可以帮助我们分析和优化游戏。在这个窗口上有游戏的不同部分所消耗的时间，例如显示渲染、动画和游戏逻辑分别消耗的时间。可以用来分析GPU、CPU、内存、渲染、音频的性能。 Profiler会对性能有一点影响，但是这个影响很小，不会影响到游戏的帧率。 可以对比代码更改前后的性能指标来进行优化分析。 **Profiler窗口 ** **Window &gt; Analysis &gt; Profiler 来打开窗口。 ** <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil1.jpg"> **控制栏 ** <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil2.png"> 窗口顶部右侧的传输控件，当游戏运行并收集数据时，单击其中任何一项会暂停游戏。可以分别查看上一帧、下一帧、记录的第一帧、最后一步的帧。 但是Profiler不记录所有的帧数据。Current会显示实时信息。Active Profiler会允许可以在编辑器或单独设备中进行分析。Save以及将记录的帧数据保存成文件，Load可以读取之前保存的。如果在按下shift按钮时单击”Load”，文件内容将附加到内存中的当前概要文件帧。 **Deep Profiling ** 打开后会分析每一个脚本，记录每一个函数的调用。深度分析会产生更大的开销，游戏运行速度会明显变慢。如果脚本代码过于复杂，就根本无法执行深度分析。 手动分析脚本代码块的开销要比使用深度分析小。使用Profiler.BeginSample 和 Profiler.EndSample脚本函数来启用和禁用对代码块的分析。 **Color Blind Mode ** 色盲模式。 **View SyncTime ** 以固定帧率或者垂直空白间隔的同步运行时，Unity在”Wait for Target FPS”中记录等待时间。Profiler中默认不显示。如果要查看就打开View SyncTime。 **Profiler Timeline ** <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil3.jpg">  Profiler窗口的上部显示随时间变化的性能数据。运行游戏时每一帧的数据都会被记录并显示最近的几百帧的数据。单击左侧的特定框架将在窗口的下方显示其详细信息。时间线上的纵轴的比例会自动调整。时间轴由几个区域组成:CPU使用、渲染和内存。如果要获得更多关于CPU使用区域的细节，可以删除内存和渲染区域。注意，标签区域中的彩色方块可以控制是否显示该数据相关的时间轴，点击方块变灰，就会在图中隐藏。 **WebGL ** 区别是不能附加到WebGL中正在运行的播放器上，并且目前无法分析WebGL的DrawCall。 **Remote Profiling ** **远程分析 ** 可以分析在另一台设备上运行的游戏，要将Unity编辑器连接到另一台设备。 **iOS ** ios启动远程分析的步骤：</p>
<ol>
<li>将ios设备连接到同一WiFi网络，或者将设备通过数据线连接。</li>
<li>File &gt; Build Settings选中Autoconnect Profiler。</li>
<li>选择Build &amp; Run。</li>
<li>当应用在设备上运行起来的时候启动Profiler窗口。</li>
</ol>
<p>有时无法自动连接，在Profiler窗口活动Profiler下拉菜单选择适当的设备启动Profiler连接。 <strong>Android</strong> WiFi或ADB 使用WiFi：</p>
<ol>
<li>禁用Android设备上的移动数据。</li>
<li>将Android设备连接到本地WiFi网络。</li>
<li>用数据线连接设备。</li>
<li>选中Unity的Build Settings对话框中的Development Build和Autoconnect Profiler，然后单击Build &amp; Run</li>
<li>当应用程序在设备上启动时，在Unity编辑器中打开Profiler窗口。</li>
</ol>
<p>如果无法自动连接，在Profiler窗口活动Profiler下拉菜单选择适当的设备启动Profiler连接。 ADB：</p>
<ol>
<li>数据线连接设备并确保ABD识别到设备。</li>
<li>选中Unity的Build Settings对话框中的Development Build和Autoconnect Profiler，然后单击Build &amp; Run，会自动创建一个ABD通道</li>
<li>当应用程序在设备上启动时，在Unity编辑器中打开Profiler窗口。</li>
<li>从Profiler窗口Active Profiler下拉菜单中选择AndroidProfiler</li>
</ol>
<p>如果要配置另一个应用程序或重启adb服务器，必须手动设置此通道。 注意:下拉菜单中的条目只有在选择的目标为Android时才可见。如果正在使用防火墙，需要确保端口54998到55511在防火墙的出站规则中是打开的，Unity用于远程分析的端口。 <strong>CPU Usage Profiler</strong> <strong>CPU使用分析器</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil4.png"> CPU使用情况分析器显示时间都被用在了游戏的哪些地方。 被选中时，下面的窗格显示所选帧的分级时间数据。有两种模式。Hierarchy mode，显示分级时间数据。Group Hierarchy mode，将时间数据分组为逻辑组(如呈现、物理、脚本)。因为任何组的子组也可以位于不同的组中，所以组时间的百分比通常加起来超过100%。上下拖动图表标签可以重新排列CPU图表的排列方式。 **选择个别项目 ** <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil5.png"> 选中项目的细节信息会显示在右侧窗口。 左侧的Self列指的是在特定函数中花费的时间，不包括调用子函数的时间。Total是总计。Time ms和Self ms列显示相同的信息，但单位是毫秒。GC Alloc列显示了在当前帧中分配了多少内存，该帧稍后由垃圾收集器（Garbage Collection）收集，将此值保持为零，以防止垃圾收集器在帧之间引起停顿。 Others记录的是所有不属于呈现、脚本、物理、Garbage Collection或VSync的区域的总数，括动画、AI、音频、粒子、网络、加载和PlayerLoop。 **Physics markers ** **物理标记 ** 各种高级物理分析器标记的含义。</p>
<ul>
<li><strong>Physics.Simulate:</strong> 从FixedUpdate调用。通过指示物理引擎(PhysX)运行其模拟来更新物理的当前状态。</li>
<li><strong>Physics.Processing:</strong> 从FixedUpdate调用。这是所有非布料物理工作处理的地方。展开此标记可以显示物理引擎内部正在进行的工作的底层细节。</li>
<li><strong>Physics.ProcessingCloth:</strong> 从FixedUpdate调用。所有的布料物理工作都在这里进行。扩展此标记将显示物理引擎内部正在进行的工作的低层细节。</li>
<li><strong>Physics.FetchResults:</strong> 从FixedUpdate调用。从物理引擎中收集物理模拟结果。</li>
<li><strong>Physics.UpdateBodies:</strong> 从FixedUpdate调用。这是所有物理实体更新它们的<strong>位置</strong>和<strong>旋转</strong>的地方，也是传递这些更新的消息的地方。</li>
<li><strong>Physics.ProcessReports:</strong> 从FixedUpdate调用。此阶段在物理FixedUpdate结束后运行，在此阶段处理响应模拟结果的所有不同阶段。Joint中断、Contacts和Triggers在这里更新和发送消息。有四个不同的子阶段:<ul>
<li><strong>Physics.TriggerEnterExits:</strong> 从FixedUpdate调用。处理OnTriggerEnter和OnTriggerExit事件。</li>
<li><strong>Physics.TriggerStays:</strong> 从FixedUpdate调用。处理OnTriggerStay事件。</li>
<li><strong>Physics.Contacts:</strong> 从FixedUpdate调用。处理OnCollisionEnter、OnCollisionExit和OnCollisionStay事件。</li>
<li><strong>Physics.JointBreaks:</strong> 从FixedUpdate调用。处理与正在断开的连接相关的更新和消息。</li>
</ul>
</li>
<li>**Physics.UpdateCloth:**从Update调用。有关布料和它们的皮肤网格的更新。</li>
<li><strong>Physics.Interpolation:</strong> 从Update调用。这个阶段处理所有物理对象的位置和旋转的插值。</li>
</ul>
<p><strong>Performance warnings</strong> <strong>性能警告</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil6.png"> CPU分析器能够检测并警告一些常见的性能问题。出现在下面的窗格的警告列中。 分析器可以检测到的具体问题：</p>
<ul>
<li><strong>Rigidbody.SetKinematic</strong> [Re-create non-convex MeshCollider for Rigidbody]</li>
<li><strong>Animation.DestroyAnimationClip</strong> [Triggers RebuildInternalState]</li>
<li><strong>Animation.AddClip</strong> [Triggers RebuildInternalState]</li>
<li><strong>Animation.RemoveClip</strong> [Triggers RebuildInternalState]</li>
<li><strong>Animation.Clone</strong> [Triggers RebuildInternalState]</li>
<li><strong>Animation.Deactivate</strong> [Triggers RebuildInternalState]</li>
</ul>
<p><strong>CPU Profiler Timeline</strong> <strong>CPU分析器时间线</strong> Mem Record: Native memory performance profiling Mem记录：本地内存性能分析 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil7.png"> 本机内存性能分析允许分析Unity本机内存管理系统中的活动，并评估它如何影响运行时性能。在Unity内存管理中搜索不需要的或资源密集型的分配模式时十分有用。 要使用此项需要手动记录。Window &gt; Analysis &gt; Profiler选择CPU Usage Profiler然后点击Timeline再选择Mem Record，然后选择记录模式：</p>
<p><strong>选项</strong></p>
<p><strong>功能</strong></p>
<p><strong>对性能的影响</strong></p>
<p><strong>None</strong></p>
<p>模式禁用。这是默认选择。</p>
<p>不存在</p>
<p><strong>Sample only</strong></p>
<p>记录内存分配、re-allocations, de-allocations、活动类型和系统。</p>
<p>低</p>
<p><strong>Callstack (fast)</strong></p>
<p>具有与Sample相同的功能，而且还记录了一个。实际上callstack从本机分配站点到callstack从本机符号转换为脚本符号的地方，我们只能看到callstack到最深的脚本符号。</p>
<p>中等</p>
<p><strong>Callstack (full)</strong></p>
<p>具有与Sample相同的功能，还记录了具有完整的脚本到本机和本机到脚本转换的callstack。</p>
<p>高</p>
<p>注意:当active Profiler只连接到独立播放器时，只支持低影响的Sample only模式。 所记录的内存分配示例以鲜红色显示在Profiler窗口中。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil8.png"> 单击Mem Record旁边的High Detail按钮以启用High Detail模式。选择一个示例来显示分配类型和系统。如果为所选分配示例记录了callstack，则还将解析并显示关联的callstack符号： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil9.jpg"> **High Detail view of Timeline ** **时间轴的高细节视图 ** Window &gt; Analysis &gt; Profiler选择CPU Usage Profiler然后选择底部的菜单点击Timeline再点击High Detail。 该模式给每次样本记录至少一个像素的宽度。可以全面查看框架中的所有活动，包括短期活动，如线程同步或内存分配。 两种模式的比较： 高细节视图 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil10.png"> 标准视图： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil11.png"> <strong>Rendering Profiler</strong> **渲染分析器 ** 时间轴显示所Batches、SetPass Calls、Draw Calls、三角形和顶点的数量。下面的窗格显示了更多的渲染统计信息，与GameView呈现Rendering Statistics窗口中显示的统计信息匹配。 **Memory Profiler ** **内存分析器 ** 两种模式： 简单： 显示了内存是如何在每帧的基础上实时地在Unity中使用的。 Unity为分配预留内存池，以避免过于频繁地向操作系统请求内存。这将显示一个预留大小，以及使用了多少。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil12.png"> 包含的内容有：</p>
<ul>
<li><strong>Unity</strong> 在本地Unity代码中被分配追踪的内存容量</li>
<li><strong>Mono</strong>使用的总的堆的大小，还有管理代码使用的堆大小。这个内存是garbage-collected</li>
<li><strong>GfxDriver</strong> 驱动程序在纹理、渲染目标、着色器和网格数据上使用的内存估计量</li>
<li><strong>FMOD</strong> 音频驱动程序的估计内存使用量</li>
<li><strong>Profiler</strong> 用于分析器数据的内存</li>
</ul>
<p>显示的数字与任务管理器或活动监视器不同，因为内存分析器无法跟踪某些使用情况。这包括一些驱动程序使用的内存，以及可执行代码使用的内存。 内存统计数据显示了一些最常见的Asset/object类型：</p>
<ul>
<li><strong>Textures</strong></li>
<li><strong>Meshes</strong></li>
<li><strong>Materials</strong></li>
<li><strong>Animations</strong></li>
<li><strong>Audio</strong></li>
<li><strong>Object Count</strong> 创建的对象的总数</li>
</ul>
<p><strong>Detailed</strong> 细节 允许获取当前状态的快照。获取这些数据需要一些时间，因此细节视图很难提供实时的详细信息。在获取一个示例之后，Profiler窗口将更新为一个树状视图。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil13.png"> 显示单个Assets和GameObject内存使用情况，还显示了GameObject存在内存中的原因。常见的原因有：</p>
<ul>
<li><strong>Assets</strong>: 从用户或本机代码引用的Asset</li>
<li><strong>Built-in Resources</strong>: Unity Editor 资源或 Unity 默认资源</li>
<li><strong>Not Saved</strong>: 被标记为 DontSave的GameObjects</li>
<li><strong>Scene Memory</strong>: GameObject 和附加的 components</li>
<li><strong>Other</strong>: GameObjects 未在上述类别中标记</li>
</ul>
<p><strong>Audio Profiler</strong> <strong>音频分析器</strong> 监视音频系统的重要性能，如总负载和声音计数。</p>
<ul>
<li><strong>Playing Sources</strong> 特定帧在场景中总的播放中的资源。监视音频是否超载。</li>
<li><strong>Paused Sources</strong> 特定帧在场景中总的暂停的资源。</li>
<li><strong>Audio Voice</strong> 实际使用的音频（FMOD通道）声音数量。 PlayOneShot 是在 Playing Sources没有显示的声音。</li>
<li><strong>Audio Memory</strong> 是被音频引擎总共使用的RAM。</li>
</ul>
<p><strong>Channel view</strong> <strong>通道视图</strong> 当单击一行时，首先突出显示AudioClipAsset，然后在层次结构中显示被播放的AudioSource。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil14.jpg"> **Channels and groups view ** **通道和组视图 ** <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil15.png"> </p>
<p><strong>Physics Profiler</strong></p>
<p><strong>物理分析器</strong> 物理分析器显示物理引擎处理过的关于物理的统计信息。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil16.png"></p>
<p><strong>性能</strong></p>
<p><strong>功能</strong></p>
<p><strong>Active Dynamic</strong></p>
<p>处于活跃状态的non-Kinematic <strong>Rigidbody</strong> 数量<strong>。</strong></p>
<p><strong>Active Kinematic</strong></p>
<p>活跃的 Kinematic Rigidbody 数量。 注意带有joints的 Kinematic Rigidbody 组件在一帧中可能会处理多次。 当 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Rigidbody.MovePosition.html">MovePosition</a> 或者 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Rigidbody.MoveRotation.html">MoveRotation</a>在一帧中调用的时候，Kinematic Rigidbody 处于活跃状态, 并且在下一帧继续保持活跃。</p>
<p><strong>Static Colliders</strong></p>
<p>在自身或者其父GameObject没有附加Rigidbody组件但附加了Colllider组件的GameObject的数量。 如果一个GameObject 或者其父对象有Rigidbody组件，则不会计数在Static Coliders。</p>
<p><strong>Rigidbody</strong></p>
<p>物理引擎处理的Rigidbody组件数量, 与其是否是休眠状态无关。</p>
<p><strong>Trigger Overlaps</strong></p>
<p>重叠触发器的数量(成对计算)。</p>
<p><strong>Active Constraints</strong></p>
<p>物理引擎处理的primitive constraint 数量。Constraints被用作关节和碰撞响应的构建块。</p>
<p><strong>Contacts</strong></p>
<p>场景中所有对撞机之间的接触对的总数，包括触发器重叠对的数量。注意，一旦碰撞器对之间的距离低于某个用户可配置的限制，就会为每个碰撞器对创建接触对，因此可能会看到为尚未接触或重叠的刚体组件生成的接触。</p>
<p><strong>注意：</strong> 这些数字可能与场景中带有物理组件的游戏对象的确切数量不相符。这是因为一些物理组件的处理速度不同，这取决于其他组件对其的影响(例如，附加的关节组件)。物理分析器没有显示睡眠Rigidbody组件的数量。这些组件不参与物理引擎，因此不被物理分析器处理。 <strong>使用物理分析器来理解性能问题</strong> 物理模拟运行在一个独立的固定频率更新周期从主逻辑的更新循环，并每次只能通过一个提前时间调用Time.fixedDeltaTime。这类似于Update和FixedUpdate之间的区别。 <strong>GPU Profiler</strong> <strong>GPU分析器</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil17.jpg"></p>
<p>显示了游戏中GPU时间都用在了哪里。</p>
<p>注意，当<strong>Graphics Jobs (Experimental)<strong>在</strong>Player</strong>设置中启用的时候GPU分析会被禁用。 <strong>远程分析支持</strong></p>
<p><strong>平台</strong></p>
<p><strong>图形API</strong></p>
<p><strong>状态</strong></p>
<p><strong>Windows</strong></p>
<p><strong>D3D9,D3D11,D3D12, OpenGL core, OpenGL ES 2.0, OpenGL ES 3.x, Vulkan</strong></p>
<p><strong>支持</strong></p>
<p><strong>Mac OS X</strong></p>
<p><strong>OpenGL core</strong></p>
<p><strong>支持</strong></p>
<p><strong>Metal</strong></p>
<p><strong>不可用。 使用 XCode’s GPU Frame Debugger UI代替。</strong></p>
<p><strong>Linux</strong></p>
<p><strong>OpenGL core, Vulkan</strong></p>
<p><strong>支持</strong></p>
<p><strong>PlayStation 4</strong></p>
<p><strong>libgnm</strong></p>
<p><strong>支持</strong></p>
<p><strong>Xbox One</strong></p>
<p><strong>D3D11</strong></p>
<p><strong>支持</strong></p>
<p><strong>WebGL</strong></p>
<p><strong>WebGL 1.0 and WebGL 2.0</strong></p>
<p><strong>不可用</strong></p>
<p><strong>Android</strong></p>
<p><strong>OpenGL ES 2.0, OpenGL ES 3.x</strong></p>
<p><strong>只支持运行NVIDIA或Intel GPUs的设备。</strong></p>
<p><strong>Vulkan</strong></p>
<p><strong>支持</strong></p>
<p><strong>iOS, tvOS</strong></p>
<p><strong>Metal, OpenGL ES 2.0, OpenGL ES 3.0</strong></p>
<p><strong>不可用。使用XCode’s GPU Frame Debugger UI 代替。</strong></p>
<p><strong>Tizen</strong></p>
<p><strong>OpenGL ES 2.0</strong></p>
<p><strong>不可用</strong></p>
<p><strong>在Unity编辑器中进行概要分析</strong> 编辑器只支持使用Direct3D 9和Direct3D 11 api在Windows上进行概要分析。它便于快速分析，因为这不需要构建播放器。但是，分析器受到运行Unity编辑器的开销的影响，会降低分析结果的准确性。</p>
<p><strong>Global Illumination Profiler</strong></p>
<p>全局光照分析器 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil18.png"></p>
<p><strong>名称</strong></p>
<p><strong>描述</strong></p>
<p><strong>Total CPU Time</strong></p>
<p>所有线程的Enlighten CPU总时间。</p>
<p><strong>Probe Update Time</strong></p>
<p>更新 <strong>Light Probes</strong>的时间。</p>
<p><strong>Setup Time</strong></p>
<p>Setup 阶段花费的时间。</p>
<p><strong>Environment Time</strong></p>
<p>处理环境光照花费的时间。</p>
<p><strong>Input Lighting Time</strong></p>
<p>用于处理输入照明的时间。</p>
<p><strong>Systems Time</strong></p>
<p>用于更新系统的时间。</p>
<p><strong>Solve Tasks Time</strong></p>
<p>用于运行辐射求解器任务的时间。</p>
<p><strong>Dynamic Objects Time</strong></p>
<p>用于更新Dynamic <strong>GameObjects</strong> 的时间。</p>
<p><strong>Time Between Updates</strong></p>
<p>更新Global Illumination之间的时间</p>
<p><strong>Other Commands Time</strong></p>
<p>用于处理其他命令的时间。</p>
<p><strong>Blocked Command Write Time</strong></p>
<p>在阻塞状态下等待命令缓冲区的时间。</p>
<p><strong>Blocked Buffer Writes</strong></p>
<p>正在阻塞的命令缓冲区的写入数。</p>
<p><strong>Total Light Probes</strong></p>
<p>场景中Light Probes的总数。</p>
<p><strong>Solved Light Probes</strong></p>
<p>自上次更新以来已解决的Light Probes数量。</p>
<p><strong>Probe Sets</strong></p>
<p>场景中设置的Light Probes数量。</p>
<p><strong>Systems</strong></p>
<p>场景中Enlighten Systems的数量。</p>
<p><strong>Pending Material GPU Renders</strong></p>
<p>在GPU上排队渲染的Albedo/Emission渲染数。</p>
<p><strong>Pending Material Updates</strong></p>
<p>等待处理的材料更新数量。</p>
<p><strong>UI Profiler</strong></p>
<p><strong>UI 处理器</strong> 专门用于游戏内UI的模块。 通过Profiler窗口的菜单访问：Add Profiler &gt; UI and UI Details <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/032119_1317_UnityProfil19.jpg"> UI Details图表有一个可切换的标记组，类似于CPU图表提供的标记组。在预览面板中，有一个按钮分离和两个下拉菜单。</p>
<ul>
<li>标记切换在UI详细信息图表上显示或隐藏事件标记。</li>
<li>Detach 会在一个单独的窗口中弹出预览。</li>
<li>  两个下拉菜单选择预览背景。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/17/hlsl%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">HLSL（2）数据类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/HLSL/">HLSL</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/d3d/">d3d</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hlsl/">hlsl</a></span><div class="content"><p>【总结，来自Microsoft Docs】 HLSL支持多种不同的内部数据类型。 Buffer，包含一个或多个标量。 Scalar，标量。 Vector，Matrix，向量和矩阵。 Sampler，Shader，Texture，采样器，着色器，纹理。 Struct，结构体，自定义结构或者类型定义。 <strong>Buffer Type</strong></p>
<p><strong>Buffer&lt;_Type_&gt; <em>Name</em>;</strong></p>
<p><strong>Buffer</strong> 所需关键字。 <em>Type</em> 标量、向量和一些矩阵HLSL类型中的一种。可以用矩阵声明一个Buffer变量，只要它能容纳4个32位的量。但是Buffer太大，编译器会产生错误。 <em>Name</em> 唯一标识变量名称的ASCII字符串。 <strong>例子：</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL21.png"> 使用Load HLSL固有函数的重载版本从缓冲区读取数据，该函数接受一个输入参数(一个整数索引)。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL22.png"> <strong>Scalar Types标量类型</strong>  HLSL 支持多种标量数据类型::</p>
<ul>
<li><strong>bool</strong> – 真或假</li>
<li><strong>int</strong> - 32位带符号整数</li>
<li><strong>uint</strong> - 32位无符号整数</li>
<li><strong>dword</strong> - 32位无符号整数</li>
<li><strong>half</strong> - 16位浮点值。此数据类型仅用于语言兼容性。Direct3D 10着色器目标将所有半数据类型映射为浮点数据类型。不能在uniform全局变量上使用half数据类型(如果需要此功能，请使用/Gec标志)</li>
<li><strong>float</strong> – 32位浮点值</li>
<li><strong>double</strong> - 64位浮点值。不能使用双精度值作为流的输入和输出。要在着色器之间传递双精度值，请将每个双精度值声明为一对uint数据类型。然后，使用asdouble函数将每个double打包到一对uint中，使用asuint函数将这对uint解压缩回double中</li>
</ul>
<p>从Windows 8开始，HLSL还支持最小精度的标量数据类型。图形驱动程序可以使用任何大于或等于其指定位精度的精度来实现最小精度标量数据类型。建议不要依赖于clamping或wrapping行为，这取决于特定的基础精度。例如，图形驱动程序可能以32位精度对<strong>min16float</strong>值执行运算。</p>
<ul>
<li><strong>min16float</strong> - 最小16位浮点值。</li>
<li><strong>min10float</strong> - 最小10位浮点值</li>
<li><strong>min16int</strong> - 最小16位带符号整数</li>
<li><strong>min12int</strong> - 最小12位带符号整数</li>
<li><strong>min16uint</strong> - 最小16位无符号整数</li>
</ul>
<p><strong>String Type字符串类型</strong> 一个ASCII字符串。没有接受字符串的操作或状态，但是效果可以查询字符串参数和注释。 <strong>Vector Type向量类型</strong> 一个向量包含1到4个标量分量，一个向量的每一个分量都必须是相同的类型。 需要Frquery.h。</p>
<p><strong>TypeNumber Name</strong></p>
<p><strong>TypeComponents</strong> 包含两个部分的单个名称。第一部分是标量类型之一。第二部分是组件的数量，必须包含1到4个组件。 <strong>Name</strong> 唯一标识变量名称的ASCII字符串。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL23.png"> 也可以使用以下语法声明： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL24.png"> 例如： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL25.png"> <strong>Matrix Type矩阵类型</strong> 矩阵是一种特殊的数据类型，它包含1到16个组件。矩阵的每个分量必须是同一类型的。</p>
<p><strong>TypeComponents Name</strong></p>
<p><strong>TypeComponents</strong> 包含三个部分的单个名称。第一部分是标量类型之一。第二部分是行数。第三部分是列数。行数和列数是1到4之间的正整数(含4)。 <strong>Name</strong> 唯一标识变量名称的ASCII字符串。 <strong>例子：</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL26.png"> 也可以像下面这样： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL27.png"></p>
<h2 id="Sampler-Type采样器类型"><a href="#Sampler-Type采样器类型" class="headerlink" title="Sampler Type采样器类型"></a><strong>Sampler Type采样器类型</strong></h2><p>Direct3D 9和Direct3D 10及更高版本之间的差异： 以下是Direct3D 9中采样器的语法。</p>
<p>sampler <em>Name</em> = <em>SamplerType</em> {Texture = <em>texture_variable</em> &gt;; [ <em>state_name = state_value;</em> ] …};</p>
<p>Direct3D 10及更高版本中采样器的语法略有改变，以支持纹理对象和采样器阵列。</p>
<p><em>SamplerType Name [Index]</em> {[ <em>state_name = state_value;</em> ] …};</p>
<p><strong>参数</strong> sampler 仅限Direct3D 9。必填关键字。 Name 唯一标识采样器变量名称的ASCII字符串。 [Index] 仅限Direct3D 10及更高版本。可选的数组大小; 大于或等于1的正整数。 SamplerType [in]采样器类型，它是以下之一：sampler，sampler1D，sampler2D，sampler3D，samplerCUBE，sampler_state，SamplerState。 Direct3D 9和Direct3D 10及更高版本之间的差异： Direct3D 10及更高版本支持一种额外的采样器类型：SamplerComparisonState。 Texture = &lt; texture_variable &gt;; 仅限Direct3D 9。一个结构变量。左侧需要纹理关键字;变量名属于尖括号内表达式的右侧。 state_name = state_value [in] 可选状态赋值。赋值的左边是状态名，右边是状态值。所有状态赋值必须出现在一个语句块中(在大括号中)。每个语句都用分号隔开。下表列出了可能的状态名。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL28.png"> 每个表达式的右侧是分配给每个状态的值。状态名和结构成员之间存在1对1的关系。 <strong>Shader Type着色器类型</strong> **Shader Type for Direct3D 10 ** 语法如下:</p>
<p><strong>SetPixelShader</strong> Compile( <strong>ShaderTarget, ShaderFunction</strong> ); <strong>SetGeometryShader</strong> Compile( <strong>ShaderTarget, ShaderFunction</strong> ); <strong>SetVertexShader</strong>Compile( <strong>ShaderTarget, ShaderFunction</strong> );</p>
<p><strong>参数</strong></p>
<p><strong>SetXXXShader</strong></p>
<p>创建着色器对象的Direct3D API调用。可以是:SetPixelShader或SetGeometryShader或SetVertexShader。</p>
<p><strong>ShaderTarget</strong></p>
<p>要编译的着色器模型。这对于任何目标都是有效的，包括所有Direct3D 9目标和着色器模型的4个目标:vs_4_0、gs_4_0和ps_4_0。</p>
<p><strong>ShaderFunction</strong></p>
<p>包含着色器入口点函数名称的ASCII字符串;这是在调用着色器时开始执行的函数。(…)表示着色器参数;这些是传递给着色器创建API的相同参数:VSSetShader或GSSetShader或PSSetShader。</p>
<p><strong>例子</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL29.png"></p>
<p>Texture Type纹理类型</p>
<p><strong>Type Name;</strong></p>
<p><strong>参数</strong></p>
<p><strong>Type</strong></p>
<p>以下类型之一:纹理(无类型，向后兼容)，Texture1D, Texture1DArray, Texture2D, Texture2DArray, Texture3D, TextureCube。元素大小必须符合4个32位的数量。</p>
<p><strong>Name</strong></p>
<p>唯一标识变量名称的ASCII字符串。</p>
<p><strong>备注</strong> 使用纹理有三个部分。</p>
<ol>
<li>声明纹理变量</li>
</ol>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL210.png"> 或者 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL211.png"></p>
<ol>
<li>声明和初始化采样器对象</li>
<li>在着色器中调用纹理函数</li>
</ol>
<p>Direct3D 10使用[模板化纹理对象](dx-graphics-hlsl-to-type.md)。</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL212.png"> <strong>Struct Type结构类型</strong> </p>
<p>struct <em>Name</em>{ [_InterpolationModifier_] _Type_[_R_x_C_] <em>MemberName</em>; … };</p>
<p><strong>参数</strong> <em>Name</em> 唯一标识结构名称的ASCII字符串。 [_InterpolationModifier_] 指定插值类型的可选修饰符。详见备注。 _Type_[_R_x_C_] 具有可选行(R) x列(C)数组大小的成员类型。结构包含至少一个元素;如果它包含多个元素，则所有元素都具有相同的类型。行数和列数是1到4之间的无符号整数。 <em>MemberName</em> 唯一标识成员名称的ASCII字符串。 <strong>备注</strong> 插值修饰符可以指定在任何结构成员或像素着色器函数的参数上。如果两个地方都出现修饰符，则外部修饰符(像素着色器参数修饰符)将覆盖内部修饰符(结构修饰符)。 <strong>例子：</strong> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL213.png"> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL214.png"> <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL215.png"> <strong>User-Defined Type用户自定义类型</strong> </p>
<p>typedef <strong>[const] Type Name[Index]</strong>;</p>
<p><strong>参数</strong></p>
<p><strong>[const]</strong></p>
<p>可选的。这个关键字显式地将类型标记为常量。</p>
<p><strong>Type</strong></p>
<p>标识数据类型;必须是HLSL内部数据类型之一。</p>
<p><strong>Name</strong></p>
<p>唯一标识变量名称的ASCII字符串。</p>
<p><strong>Index</strong></p>
<p>可选的数组的大小。必须是介于1和4之间的无符号整数。</p>
<p>用户定义的类型不区分大小写。为了方便起见，在超全局范围内自动定义了以下类型： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0714_HLSL216.png"> 磅号(#)表示1到4之间的整数。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/17/hlsl%EF%BC%881%EF%BC%89%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95/">HLSL（1）变量语法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/HLSL/">HLSL</a></span><div class="content"><p>【总结，来自Microsoft Docs】 声明HLSL语法变量的规则</p>
<p>[_Storage_Class_] [<em>Type_Modifier_] <em>Type Name_[<em>Index_] [</em>: Semantic_] [</em>: Packoffset_] [</em>: Register_]; [_Annotations_] [_= Initial_Value_]</p>
<p><strong>参数</strong> <strong><em>Storage_Class</em></strong> 可选的存储类修饰符，提供编译器关于变量范围和生存期的提示。可以按任何顺序指定修饰符。 <strong>extern</strong> 将全局变量标记为着色器的外部输入;这是所有全局变量的默认标记。不能是<strong>static</strong>的。 <strong>nointerpolation</strong> 从顶点着色器输出后，传递到像素着色器前不进行插值处理。 <strong>precise</strong> 防止编译器进行影响此变量的不安全优化。精确的修饰符还确保编译器保持操作顺序，并且必须考虑到常量和流输入中NaN(不是数字)和INF(无限)值的可能性。如果没有精确的修饰符，编译器可以执行不考虑NaN和INF值的优化和数学操作。这些优化和数学操作不是IEEE安全的。当使用precise关键字时，禁止对所有影响变量的计算进行这些优化。以这种方式控制优化的能力在编写细分着色器以保持water-tight时非常有用。 <strong>shared</strong> 标记用于在效果之间共享的变量。这是给编译器的提示。 <strong>groupshared    ** 为计算着色器的共享线程组内存标记一个变量。D3D11中最大为32kb。 <strong>static</strong> 标记一个局部变量，使其初始化一次，并在函数调用之间保持不变。如果声明不包含初始化器，则将该值设置为零。标记为静态的全局变量对应用程序不可见。 <strong>uniform</strong> 标记一个变量，该变量的数据在着色器的整个执行过程中都是常量(例如顶点着色器中的材质颜色)。默认情况下，全局变量是uniform的。可以随时在不同着色器中调用同一个uniform。 <strong>volatile</strong> 标记经常更改的变量。这是给编译器的提示。此存储类修饰符仅适用于局部变量。</strong>当前编译器会忽略该Storage_Class修饰符。** <strong><em>Type_Modifier</em></strong> 可选变量类型修饰符。 <strong>const</strong> 标记一个不能被着色器改变的变量，它必须在变量声明中初始化。默认情况下，全局变量被认为是const。 <strong>row_major</strong> 标记一个变量，该变量将四个组件存储在一行中，这样它们就可以存储在一个常量寄存器中。 <strong>column_major</strong> 标记一个在一列中存储4个组件的变量，以优化矩阵数学。 <strong>例子</strong> 变量声明 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0442_HLSL11.png"> **Group Shared ** HLSL允许计算着色器的线程通过共享内存交换值。HLSL提供屏障原语，例如GroupMemoryBarrierWithGroupSync，确保对着色器中共享内存的读和写的正确顺序，并避免数据争用。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0442_HLSL12.png">  **Packing ** 打包大小足以防止跨越寄存器边界的向量和标量的子组件。 <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0442_HLSL13.png"> 打包的元素可能会重叠，但编译器不会给出错误或警告。如下： <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031719_0442_HLSL14.png"> Element2和Element3与Element1的x与y重叠。 **packoffset ** 可选着色器常量包装关键字</p>
<p>: packoffset( c[Subcomponent][.component] )</p>
<p><strong>参数</strong> <strong>packoffset</strong> 所需关键字。 <strong>c</strong> 只适用于常数寄存器(c)。 <strong>[Subcomponent][.component]</strong> 可选子组件和组件。子组件是一个寄存器号，它是一个整数。一个组件的形式是[.xyzw]。 <strong>备注</strong> 在声明变量类型时使用此关键字手动pack着色器常量。pack常量时，不能混合常量类型。编译器对全局常量和一致常量的行为略有不同。编译器将全局变量作为全局常量添加到_$ global cbuffer_中。自动pack的元素(声明没有pack偏移量的元素)将出现在最后一个手动打包的变量之后。在打包全局常量时，可以混合使用类型。 当着色器在effects框架之外编译时，编译器将函数的参数列表中的统一参数添加到_$Param_常量缓冲区中。在effect框架内编译时，统一常量必须解析为全局范围内定义的统一变量。uniform常数不能手动偏移。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/%E3%80%90unity%E4%BC%98%E5%8C%96%E3%80%91drawcall/">【Unity优化】DrawCall</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/">unity3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/Unity%E4%BC%98%E5%8C%96/">Unity优化</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Unity学习笔记</a></span><div class="content"><p>【Unity优化】DrawCall 【总结，来自Unity Documentation】 <strong>什么是DrawCall</strong> 简单翻译即为绘制调用。指的是CPU对图形库接口的调用。 在现代绘制流水线过程中，CPU与GPU协同并行工作来提升效率。CPU将各种所需要的信息和命令发送到缓冲区，GPU接收并执行命令。在GPU执行命令的同时，CPU可以继续在缓冲区中添加命令。GPU完成一个命令之后，会在缓冲区中取出一个命令继续执行。 [caption id=”attachment_1135” align=”aligncenter” width=”680”]<a target="_blank" rel="noopener" href="http://www.muchenhen.com/wp-content/uploads/2019/03/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97.jpg"><img src="http://www.muchenhen.com/wp-content/uploads/2019/03/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1024x683.jpg" alt=" = =写字母避免暴露字丑（并没有……"></a> = =写字母避免暴露字丑（并没有……[/caption] DrawCall就是一种命令。  <strong>DrawCall对效率的影响</strong>  CPU在每次调用DrawCall命令之前，需要进行很多准备工作，比如检查渲染状态，提交渲染所需要的数据。完成了这些准备工作之后GPU就会开始本次的渲染。由于GPU渲染速度较快，往往快于CPU准备工作的速度。当DrawCall的次数过多时，CPU需要准备大量工作，而此时GPU则可能没有且无法执行命令，即GPU存在大量空闲。  提交大量较小的DrawCall会造成CPU性能瓶颈。  <strong>优化方向和思路</strong>  综上所述，减少DrawCall的调用次数，将较小的，使CPU和GPU保持并行计算，让GPU在单位时间内充分利用，极大提高整体效率。  <strong>注意</strong>  如果合并大量DrawCall导致CPU要传输的资源过多甚至大于总线带宽时，GPU依然只能等待。而且执行合并操作也会占用CPU内存。所以DrawCall并非越小越好，要保持与其他相关属性的平衡。  <strong>Unity使用的两种方法</strong>  动态批处理  静态批处理  <strong>批处理材质设置</strong>  只有游戏对象使用相同的材质才可以合并。  如果两个材质只有纹理不一样，可以合并两个纹理生成一个纹理图集（Texture Atlas），当纹理在用一个纹理图集中，两个材质就可以改为只用一个材质。  在脚本中访问这种共享材质时，Renderer.material会生成一个副本，使用Renderer.sharedMaterial会保持只有一个共享材质。  而即使是不同材质，只要阴影通道所需的材质值相同，阴影投射也可以使用动态批处理。  <strong>动态批处理（网格）</strong>  Unity会自动的将使用相同材质并满足合并标准的游戏对象移动到同一个DrawCall中。比如添加1个默认cube和添加若干个默认cube，在Profiler中可以看到DrawCall的次数并没有增加。  批处理对GameObject的每一个顶点都有一定的开销，超过900个顶点属性和超过300个顶点的网格不适用动态批处理。<strong>如果着色器使用了顶点位置、法线、UV0、UV1和切线就只能支持到180个顶点。</strong>  在transform中有镜像，如scale中一个为+1一个为-1，也不会使用动态批处理。  多通道的着色器会终止批处理。预计算光照渲染路径需要绘制两次游戏物体，会禁用动态批处理。  动态批处理的工作原理是在CPU上将所有GameObject顶点转换为世界空间，因此只有当工作量小于DrawCall时才有优势。DrawCall的资源需求取决于许多因素，主要原因是图形API的使用。例如，在控制台或一些现代API上，DrawCall开销通常要低得多，这种情况下动态批处理通常没有什么优势。  <strong>动态批处理（粒子系统、Line Renderers、Trail Renderers）</strong>  对于Unity动态生成的几何组件，动态批处理的工作方式与对网格的工作方式不相同。  对于每个兼容的渲染器类型，Unity将所有可批处理的内容构建到一个大的顶点缓冲区中。  渲染器会为批处理设置材质状态。  Unity将顶点缓冲区绑定到图形设备。  对于批处理中的每个渲染器，Unity将把offset更新到顶点缓冲区（VB），然后提交一个新的DrawCall。  图形设备调用的成本中，设置材质状态是最慢的，将不同offset的DrawCall提交到共享顶点缓冲区中非常快。  这种方法非常类似于Unity在使用静态批处理时提交DrawCall的方式。  <strong>静态批处理</strong>  静态批处理允许引擎减少对任何尺寸的几何图形的DrawCall，前提是共享相同的材质，并且不移动。它不在CPU上进行顶点转换，它通常比动态批处理更有效，但是使用更多的内存。为了利用静态批处理，需要显式地指定GameObjects是静态的，并且在游戏中不移动、旋转或缩放。使用检查器中的静态复选框将GameObjects标记为静态的（static）。  <img src="https://www.muchenhen.com/wp-content/uploads/2019/03/031619_1443_UnityDrawCa1.png">  使用静态批处理需要额外的内存来存储组合的几何图形。如果多个GameObject在静态批处理之前共享相同的几何体，那么将在编辑器或运行时为每个GameObject创建一个几何体副本。但是有时为了保持更小的内存占用，不得不牺牲渲染性能，需要避免对某些GameObject进行静态批处理。例如，”森林”类的游戏对象中有很多”树”，将”树”标记为静态会对内存产生严重影响。在内部，静态批处理的工作原理是将静态游戏对象转换到世界空间，并为它们建立一个共享的顶点和索引缓冲区。如果启用了优化的Mesh__ Data__(在玩家设置中)，那么在创建顶点缓冲区时，Unity会删除没有被任何着色器变量使用的顶点元素。有一些特殊的关键字检查来执行。例如，如果Unity没有检测到LIGHTMAP_ON关键字，它将从批处理中删除lightmap UVs。然后，对于同一批处理中的可见GameObjects, Unity执行一系列简单的DrawCall，每个调用之间几乎没有状态变化。从技术上讲，Unity并不保存API 绘制调用，而是保存它们之间的状态更改(对于资源密集型部分)。大多数平台上的批处理限制是64k个顶点和64k个索引(OpenGL ES上是48k个索引，macOS上是32k个索引)。  <strong>Tips</strong>  目前，蒙皮网格、布和其他类型的渲染组件没有批处理。  渲染器只与其他相同类型的渲染器进行批处理。  半透明着色器通常要求GameObject按back-to-front顺序渲染。Unity首先按照这个顺序对GameObjects进行排序，然后尝试对它们进行批处理，但由于必须严格满足顺序，这通常意味着与不透明的GameObjects相比，半透明渲染器可以实现的批处理更少。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/%E3%80%90unity%E4%BC%98%E5%8C%96%E3%80%91%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/">【Unity优化】常见优化方式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/">unity3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/unity3d/Unity%E4%BC%98%E5%8C%96/">Unity优化</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Unity学习笔记</a></span><div class="content"><p><a target="_blank" rel="noopener" href="https://www.muchenhen.com/wp-content/uploads/2019/03/%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91.png"><img src="https://www.muchenhen.com/wp-content/uploads/2019/03/%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91-929x1024.png"></a></p>
<p>d点击查看原图</p>
<p>常见优化方式  </p>
<ul>
<li>性能检测  <ul>
<li>UnityProfiler  <ul>
<li>DrawCall  </li>
</ul>
</li>
<li>UnityStatistics  </li>
</ul>
</li>
<li>资源优化  <ul>
<li>资源优化标准  </li>
<li>模型优化  </li>
<li>贴图优化  <ul>
<li>材质、贴图和drawcall关系  </li>
</ul>
</li>
<li>资源冗余与重复  </li>
<li>资源检测与分析  </li>
</ul>
</li>
<li>GPU优化  <ul>
<li>CPU与GPU分工  </li>
<li>LOD-层次细节  </li>
<li>Occlusion Culling遮挡剔除  </li>
<li>Lightmapping光照贴图  </li>
<li>Mesh合并  </li>
</ul>
</li>
<li>CPU优化  <ul>
<li>Object Pooling资源池  </li>
</ul>
</li>
<li>其他  <ul>
<li>优化工具  <ul>
<li>UWA  </li>
</ul>
</li>
<li>  编译性能优化</li>
</ul>
</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By 木尘痕</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">天道作何，吞恨者多 <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">豫ICP备17048032号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>