<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="放一些笔记的地方"><meta name="keywords" content=""><meta name="author" content="木尘痕"><meta name="copyright" content="木尘痕"><title>一点浩然气 千里快哉风 | 风生之谷</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/muchenhen/muchenhen.github.io/master/xuange.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://github.com/muchenhen/muchenhen.github.io/blob/master/XuanGe.jpg?raw=true"></div><div class="author-info__name text-center">木尘痕</div><div class="author-info__description text-center">放一些笔记的地方</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">172</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://alec-ray.github.io/">止戈</a></div></div></div><nav id="nav" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">风生之谷</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">全部文章</a><a class="site-page" href="/tags">标签分类</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/contact">联系</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">风生之谷</div><div id="site-sub-title">一点浩然气 千里快哉风</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/11/stl%EF%BC%9Aset%E4%B8%8Emultset-%E5%AE%B9%E5%99%A8/">STL：set与multset 容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>set的语法定义如下：</p>
<p>template &lt;class Key,</p>
<p>    class Traits=less<Key>,</p>
<p>    class Allocator=allocator<Key>&gt;</p>
<p>class set</p>
<p>multiset如下：</p>
<p>template &lt;class Key, class Compare =less <Key>, class Allocator =allocator <Key>&gt;</p>
<p>class multiset</p>
<p>set根据特定的排序准则，自动将元素进行排序。multiset允许有重复元素，set不允许。</p>
<p>需要头文件<set></p>
<p>命名空间为std</p>
<p>只要是可以被排序的元素类型都可以作为set的元素类型。默认排序准则是less（一个函数对象），从小到大。定义里的第三个实参可有可无，默认的内存模型是allocator，同样由标准库提供。</p>
<p>排序准则必循遵循strict weak ordering，含义如下：</p>
<ul>
<li>  必须是非对称的，比如操作符&lt;，x&lt;y为真则y&lt;x必须是假</li>
<li>  必须是可传递的，比如a&lt;b，b&lt;c，则a&lt;c</li>
<li>  必须是非自反的，x&lt;x为假</li>
<li>  必须是等效传递的，意思是，对于操作符&lt;，若!(a&lt;b) &amp;&amp; !(b&lt;a)为真，且!(b&lt;c) &amp;&amp; !(c&lt;b)为真，那么!(a&lt;c) &amp;&amp; !(c&lt;a)为真。意味着对于判别式op(),op(a,c),op(b,a),op(b,c),op(c,b)都为假，则op(a,c),op(c,a)为假。</li>
</ul>
<p>当两个元素被判定为没有任何一个小于另一个，就会被视为重复。</p>
<p>multiset的等效元素次序是随机但是稳定的。插入和删除元素依然会保持等效元素的相对次序。</p>
<p>不能直接改变元素值，因为回打乱原有的顺序。两个容器要改变元素值必须先删除旧元素，再插入新元素。两个容器都不提供直接访问元素的操作函数。通过迭代器进行间接访问有一个限制，对于迭代器来说，元素值是常量。</p>
<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>对于排序准则，有两种方式可以定义。</p>
<p>template参数定义，例如：</p>
<p>set&lt;int,greater<int>&gt; coll;</p>
<p>第二个参数可以认为是排序准则的“类型”。实际排序准则是容器产生的函数对象。</p>
<p>以构造函数参数定义：</p>
<p>这种情况，同一个类型可以运用可以运用不同的排序准则，而排序准则的初始值或状态也可以不同，如果运行期才获得排序准则，而且需要用到不同的排序准则，这一方式可派上用场。如果没有指定特定的排序准则，就会采用默认排序准则，即函数对象less&lt;&gt;</p>
<p>排序准则也被用来检验元素相等性。这样做是有一些优点的：</p>
<p>只需要传递一个实参作为排序准则，不需要针对元素类型提供==运算符，可以堆“相等性”有相反的定义，不造成混淆。但是这种检验会花费较长的时间，因为可能会需要比较第二次。</p>
<p>需要注意。两个容器用==比较时内部元素会用自己的==运算符。</p>
<p>构造和析构函数表</p>
<p>操作</p>
<p>效果</p>
<p>set c</p>
<p>默认构造，不含任何元素建立一个空的</p>
<p>set c(op)</p>
<p>复制构造</p>
<p>set c(c2)</p>
<p>复制构造，参数是另一个类型相同的容器，会复制每个元素</p>
<p>set c = c2</p>
<p>复制构造</p>
<p>set c(cv)</p>
<p>move构造（移动构造），c11</p>
<p>set c = rv</p>
<p>移动构造，c11</p>
<p>set c(begin,end)</p>
<p>左闭右开为初值建立一个容器</p>
<p>set c(begin,end,op)</p>
<p>左闭右开为初值，以op为排序准则</p>
<p>set c(initlist)</p>
<p>以initlist为初见建立。C11</p>
<p>set c = initlist</p>
<p>同上</p>
<p>c.~set()</p>
<p>析构函数</p>
<p>上表中的set可以是如下形式：</p>
<p>set</p>
<p>效果</p>
<p>set<Elem></p>
<p>一个set，以less&lt;&gt;为准则排序</p>
<p>set&lt;Elem, Op&gt;</p>
<p>一个set，以op()为排序准则</p>
<p>multiset<Elem></p>
<p>一个multiset，以less&lt;&gt;为排序准则</p>
<p>multiset<Elem></p>
<p>一个multiset，以op&lt;&gt;为排序准则</p>
<h2 id="非变动性操作"><a href="#非变动性操作" class="headerlink" title="非变动性操作"></a>非变动性操作</h2><p>用来查询大小，相互比较。</p>
<p>注意元素比较动作只适合于类型相同的容器。要比较不同类型的容器，必须采用标准库比较算法。</p>
<p>操作</p>
<p>效果</p>
<p>c.key_comp()</p>
<p>返回比较准则</p>
<p>c.value_comp()</p>
<p>返回针对value的比较准则</p>
<p>c.empty()</p>
<p>返回是否为空</p>
<p>c.size()</p>
<p>返回目前元素数量</p>
<p>c.max_size()</p>
<p>返回元素个数的最大可能</p>
<p>==</p>
<p> </p>
<p>!=</p>
<p> </p>
<p>&lt;</p>
<p> </p>
<p>&gt;</p>
<p> </p>
<p>&lt;=</p>
<p> </p>
<p>&gt;=</p>
<p> </p>
<p>特殊查找函数</p>
<p>对于set和multiset，在元素快速查找方面有优化设计，所以提供了特殊的查找函数。这些函数是同名的STL算法的特殊版本，时间复杂度更低。</p>
<p>操作</p>
<p>效果</p>
<p>c.count(value)</p>
<p>返回值为value的元素个数</p>
<p>c.find(value)</p>
<p>返回元素值为value的第一个元素，找不到就返回end()</p>
<p>c.lower_bound(value)</p>
<p>返回value的第一个可安插的位置。即元素值&gt;=value的第一个位置</p>
<p>c.upper_bound(value)</p>
<p>返回value的最后一个可插入的位置。即元素值&gt;value的第一个位置</p>
<p>c.equal_range(value)</p>
<p>返回value可以插入的第一个位置和最后一个位置，也就是元素值==value的区间</p>
<p>关于上面的几个函数的实例：</p>
<p>#include<br>#include </p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    set c;<br>    c.insert(1);<br>    c.insert(2);</p>
<pre><code>c.insert(4);
c.insert(5);
c.insert(6);

cout &lt;&lt; &quot;lower\_bound(3):&quot; &lt;&lt; \*c.lower\_bound(3) &lt;&lt; endl;
cout &lt;&lt; &quot;upper\_bound(3):&quot; &lt;&lt; \*c.upper\_bound(3) &lt;&lt; endl;
cout &lt;&lt; &quot;equal\_range(3):&quot; &lt;&lt; \*c.equal\_range(3).first &lt;&lt; &quot; &quot; 
                          &lt;&lt; \*c.equal\_range(3).second &lt;&lt; endl;

cout &lt;&lt; endl;
cout &lt;&lt; &quot;lower\_bound(5):&quot; &lt;&lt; \*c.lower\_bound(5) &lt;&lt; endl;
cout &lt;&lt; &quot;upper\_bound(5):&quot; &lt;&lt; \*c.upper\_bound(5) &lt;&lt; endl;
cout &lt;&lt; &quot;equal\_range(5):&quot; &lt;&lt; \*c.equal\_range(5).first &lt;&lt; &quot; &quot;
                          &lt;&lt; \*c.equal\_range(5).second &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-10.png" alt="_ bound (3) : 4 
1 over 
_ bound (3) : 4 
pper 
equal_range (3) : 4 4 
_ bound (5) : 5 
1 over 
_ bound (5) : 6 
pper 
equal_range (5) 6 "></p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>两个容器只提供任何容器都提供的基本复制操作，赋值操作的两端容器必须具备相同类型。排序准则本身可以不同，但“类型”必须相同。如果排序准则不同，准则本身也会连同容器一并被赋值或者交换。</p>
<p>操作</p>
<p>效果</p>
<p>c = c2</p>
<p>很明显的操作我懒得写了……以下省略</p>
<p>c = rv</p>
<p>右值以移动构造的方式给c</p>
<p>c = initlist</p>
<p> </p>
<p>c1.swap(c2)</p>
<p> </p>
<p>swap(c1,c2)</p>
<p> </p>
<h2 id="迭代器相关函数"><a href="#迭代器相关函数" class="headerlink" title="迭代器相关函数"></a>迭代器相关函数</h2><p>两个容器不提供元素直接访问，所以只能采取范围for循环或者使用迭代器。</p>
<p>需要注意的是，和所有关联式容器类似，迭代器是双向迭代器，对于只能接受随机访问迭代器的算法，这两个容器无法使用。并且从迭代器的角度去看，所有容器内的元素都会被视为常量，这样才能确保元素不会被改动以至于打乱原有的顺序。如果要移除容器内的元素，只能使用容器的成员函数。</p>
<p>操作</p>
<p>效果</p>
<p>c.begin()</p>
<p>返回一个双向迭代器指向第一个元素</p>
<p>c.end()</p>
<p>返回一个双向迭代器指向最后一个元素的下一个位置</p>
<p>c.cbegin()</p>
<p>返回一个const双向迭代器指向第一个元素，C11</p>
<p>c.cend()</p>
<p>返回一个const双向迭代器指向最后一个元素的下一个位置，C11</p>
<p>c.rbrgin()</p>
<p>返回一个反向的迭代器指向反向迭代的第一个元素</p>
<p>c.rend()</p>
<p>返回一个反向的迭代器指向反向迭代的最后一个元素的下一个位置</p>
<p>c.crbegin()</p>
<p>返回一个const反向迭代器指向反向迭代的第一个元素，C11</p>
<p>c.crend()</p>
<p>返回一个const反向迭代器指向反向迭代的最末元素的下一位置，C11</p>
<h2 id="元素的插入和删除"><a href="#元素的插入和删除" class="headerlink" title="元素的插入和删除"></a>元素的插入和删除</h2><p>对于multiset，因为存在元素的值相同的元素，部分成员函数会保存等值元素之间的相对次序插入的元素会被放在既有的等值元素的末尾。</p>
<p>操作</p>
<p>效果</p>
<p>c.insert(value)</p>
<p>插入value值返回新元素的位置，无论插入是否成功</p>
<p>c.insert(pos,value)</p>
<p>同上，这里的pos是一个提示值，提示了查找插入位置的起点，正确的提示值可以加快查找速度</p>
<p>c.insert(begin,end)</p>
<p>区间插入，无返回值</p>
<p>c.insert(initlist)</p>
<p>初始列表插入，无返回值，C11</p>
<p>c.emplace(args……)</p>
<p>插入一个以args为初值的元素，返回新元素的位置</p>
<p>c.emplace_hint(pos,args…)</p>
<p>同上，pos为位置提示</p>
<p>c.erase(value)</p>
<p>删除与value相等的所有元素，返回被删除的个数</p>
<p>c.erase(pos)</p>
<p>删除迭代器位置pos上的元素，无返回值</p>
<p>c.erase(begin,end)</p>
<p>删除区间内的所有元素，无返回值</p>
<p>c.clear()</p>
<p>移除所有元素，清空容器</p>
<p>注意insert()和emplace()返回类型不完全相同。原因是set不允许重复而multiset允许。如果set插入一个已经存在的值，插入动作将失败，所以set返回类型是以pair组织起来的两个值：</p>
<p>pair的second成员表示是否插入成功</p>
<p>pair中的first成员表示新元素的位置，或者已经存在的同值元素的位置。</p>
<p>set提供的接口：</p>
<p>// (1) 单个元素<br>pair insert(const value_type&amp; Val);</p>
<p>// (2) single element, perfect forwarded<br>template<br>pair insert(ValTy&amp;&amp; Val);</p>
<p>// (3) single element with hint<br>iterator insert( const_iterator Where, const value_type&amp; Val);</p>
<p>// (4) single element, perfect forwarded, with hint<br>template<br>iterator insert( const_iterator Where, ValTy&amp;&amp; Val);</p>
<p>// (5) range<br>template<br>void insert(InputIterator First,  InputIterator Last);</p>
<p>// (6) initializer list<br>void insert( initializer_list IList);</p>
<p>//emplace<br>template<br>pair emplace(<br>    Args&amp;&amp;… args);</p>
<p>//emplace_hint<br>template<br>iterator emplace_hint(<br>    const_iterator where,<br>    Args&amp;&amp;… args);</p>
<p>//erase<br>iterator erase(<br>    const_iterator Where);</p>
<p>iterator erase(<br>    const_iterator First,<br>    const_iterator Last);</p>
<p>size_type erase(<br>    const key_type&amp; Key);</p>
<p>multiset提供的节口</p>
<p>//multiset::insert // (1) single element pair insert( const value_type&amp; Val); // (2) single element, perfect forwarded template pair insert( ValTy&amp;&amp; Val); // (3) single element with hint iterator insert( const_iterator Where, const value_type&amp; Val); // (4) single element, perfect forwarded, with hint template iterator insert( const_iterator Where, ValTy&amp;&amp; Val); // (5) range template void insert( InputIterator First, InputIterator Last); // (6) initializer list void insert( initializer_list IList); //multiset::emplace template iterator emplace(Args&amp;&amp;… args); //multiset::emplace_hint template iterator emplace_hint( const_iterator where, Args&amp;&amp;… args); //multiset::erase iterator erase( const_iterator Where); iterator erase( const_iterator First, const_iterator Last); size_type erase( const key_type&amp; Key);</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>两个容器是以节点为基础的容器，如果节点构建失败，容器仍保持原样。由于析构函数通常不抛出异常，所以节点的删除不可以失败。</p>
<p>对于多重元素安插动作，保持元素次序这个条件会造成异常抛出时必须完全恢复原状变得不可能。因此只有单一元素插入时才支持除了成功就是无效的操作原则。</p>
<p>运用实例</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-11.png" alt="6 一 一 41 3 礻 3 
5 试 2 除 4 除 4 
3 子 4 、 7 一 6 
冂 乙 亠 凵 刂 "></p>
<p>运行期指定排序准则</p>
<p>在必须在运行期处理排序准则或者需要对同一种数据类型采用不同的排序准则，就需要一个用来表现排序准则的特殊类型。</p>
<p>下面是一个实例</p>
<p>代码托管到了github：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/muchenhen/MySTLSample/tree/master/STL%E5%AE%B9%E5%99%A8/set%E4%B8%8Emultiset">运行时排序准则</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/03/stl%EF%BC%9Aforward-list%E5%AE%B9%E5%99%A8/">STL：forward_list容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>该容器从c11才有，内部是一个单向链表。</p>
<p>需要头文件&lt;forward_list&gt;</p>
<p>在std中定义如下：</p>
<p>template &lt;class Type,</p>
<p>    class Allocator = allocator<Type>&gt;</p>
<p>class forward_list</p>
<p>forward_list是一个受限制的list，优点是内存用量较少，行动也比较快。比起list有一些约束：</p>
<p>不提供双向迭代器，不支持反向迭代器。</p>
<p>不提供成员函数size()</p>
<p>没有指向最后一个元素的anchor，所以没有back() push_back() pop_back()</p>
<p>对于所有插入操作的函数都有特殊版本。例如insert()变为insert_back()，必须传递第一个被处理元素的前一个位置，将新元素插入到第一个实参所表示的元素后。同样，begin()会变成before_begin()，会返回头指针（指向头结点的指针，即单链表的anchor）</p>
<p>不提供size()函数的原因是设计者要求forward_list()与手写的单向链表相比不造成额外的时间或者空间开销。</p>
<p>其余事项与list基本相同。</p>
<p>如果必须计算元素个数，可以使用distance，定义于头文件 <iterator>，返回从 first 到 last 的路程。</p>
<p>forward_list<int> list = { 1, 2, 3 };</p>
<p>cout &lt;&lt; distance(list.begin(),list.end());</p>
<p>输出结果是3</p>
<p>元素访问</p>
<p>唯一能够直接访问的元素是第一个元素</p>
<p>c.front()，不检查是否存在第一个元素</p>
<h2 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h2><p>只能以前行方向遍历元素，没有反向迭代器，无法调用双向或者随机迭代器的算法。排序只能用自己的成员函数。</p>
<p>注意，before_begin()和cbefore_begin()作为第一个参数使用任何STL函数都会导致运行时出错。</p>
<p>所有以after结尾的插入函数，会将元素插入到指定位置之后，因为forwardlist没有指向前一个元素的指针。如果后缀after的元素传入了end()作为参数，会产生不明确的行为，如果要在尾部插入一个元素，需要传入终端元素的位置。</p>
<p>和list一样forwardlist可以在常量时间内删除和插入元素。forwardlist提供和list几乎一致的成员函数splice_after()</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>对于和list相同的函数，异常处理方式完全相同。</p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>创建、复制、删除</p>
<p>操作</p>
<p>结果</p>
<p>forward_list<Elem> c</p>
<p>默认构造</p>
<p>forward_list<Elem> c(c2)</p>
<p>复制构造</p>
<p>forward_list<Elem> c = c2</p>
<p>复制构造</p>
<p>forward_list<Elem> c(rvalue)</p>
<p>move构造</p>
<p>forward_list<Elem> c=crvalue</p>
<p>move构造</p>
<p>forward_list<Elem> c(n)</p>
<p>默认构造一个大小为n的forward_list</p>
<p>forward_list<Elem> c(n,elem)</p>
<p>生成一个有n个元素的forward_list，每个元素都是elem</p>
<p>forward_list<Elem> c(begin,end)</p>
<p>以begin和end的左闭右开区间构造一个forward_list</p>
<p>forward_list<Elem> c(initforward_list)</p>
<p>以初值列表构造forward_list</p>
<p>forward_list<Elem> c = initforward_list</p>
<p>同上</p>
<p>c.~forward_list()</p>
<p>销毁所有元素，释放内存</p>
<p>非变动性操作</p>
<p>操作</p>
<p>效果</p>
<p>c.empty()</p>
<p>返回容器是否为空</p>
<p>c.size()</p>
<p>返回目前容器内元素个数</p>
<p>c.max_size()</p>
<p>返回元素个数的最大可能值</p>
<p>c1 == c2</p>
<p> </p>
<p>!=</p>
<p> </p>
<p>&lt;</p>
<p> </p>
<p>&gt;</p>
<p> </p>
<p>&lt;=</p>
<p> </p>
<p>&gt;=</p>
<p> </p>
<p>赋值操作</p>
<p>操作</p>
<p>效果</p>
<p>c = c2</p>
<p>赋值</p>
<p>c = rv</p>
<p>将右值move给c</p>
<p>c = initlist</p>
<p>初始化表赋给c</p>
<p>c.assign(n,elem)</p>
<p>n个elem赋给c</p>
<p>c.assign(begin,end)</p>
<p>左闭右开赋给c</p>
<p>c.assign(initlist)</p>
<p>初始化表赋给c</p>
<p>c1.swap(c2)</p>
<p>交换c1，c2</p>
<p>swap(c1,c2)</p>
<p>比上面那个慢，全局函数</p>
<p>迭代器操作</p>
<p>操作</p>
<p>效果</p>
<p>c.begin()</p>
<p>返回一个双向迭代器指向第一个元素</p>
<p>c.end()</p>
<p>返回指向最后一个元素的双向迭代器</p>
<p>c.cbegin()</p>
<p>第一个的const，c11</p>
<p>c.cend()</p>
<p>第二的const，c11</p>
<p>c.before_begin()</p>
<p>返回一个forward迭代器指向第一个元素的前一个位置</p>
<p>c.cbefore_begin()</p>
<p>返回一个const forward迭代器指向第一元素的前一位置</p>
<p>插入删除</p>
<p>操作</p>
<p>效果</p>
<p>异常处理</p>
<p>c.push_front()</p>
<p>头插</p>
<p>成功或者没有任何效果</p>
<p>c.pop_front()</p>
<p>头删，不返回</p>
<p>不抛出异常</p>
<p>c.insert_after(pos,elem)</p>
<p>指定位置后插入</p>
<p>成功或者没有任何效果</p>
<p>c.insert_after(pos,n,elem)</p>
<p>指定位置后插入n个elem，返回第一个新元素的位置</p>
<p>成功或者没有任何效果</p>
<p>c.insert_after(pos,begin,end)</p>
<p>指定位置后插入左闭右开的所有元素，返回第一个新元素位置</p>
<p>成功或者没有任何效果</p>
<p>c.insert_after(pos,initlist)</p>
<p>指定位置后插入初始化列的所有元素并返回第一个新元素的位置</p>
<p>成功或者没有任何效果</p>
<p>c.emplace_after(pos,args…)</p>
<p>在pos后插入以args为初值的元素，并返回新元素位置，c11</p>
<p> </p>
<p>c.emplace_front(args…)</p>
<p>上面的函数的头插实现，不返回，c11</p>
<p> </p>
<p>c.erase_after(pos)</p>
<p>删除指定位之后的元素，不返回任何</p>
<p>不抛出异常</p>
<p>c.erase_after(begin,end)</p>
<p>删除区间，不返回任何</p>
<p>不抛出异常</p>
<p>c.remove(val)</p>
<p>删除所有值为val的元素</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.remove_if(op)</p>
<p>上文讲过了</p>
<p>如上</p>
<p>c.resize(num)</p>
<p>元素数量改为num，如果变多，多出来的默认构造</p>
<p>成功或者没有任何效果</p>
<p>c.resize(num,elem)</p>
<p>如果变多，多出来的为elem</p>
<p>成功或者没有任何效果</p>
<p>c.clear()</p>
<p>删除所有元素</p>
<p>不抛出异常</p>
<p>特殊变动性操作</p>
<p>操作</p>
<p>效果</p>
<p>异常处理</p>
<p>c.unique()</p>
<p>如果存在临近且数值相同的元素，只保留一个</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.unique(op)</p>
<p>如果存在相邻元素满足op，就只保留一个</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.splice_after(pos,c2)</p>
<p>把c2的所有元素搬到c的pos后</p>
<p>不抛出异常</p>
<p>c.splice_after(pos,c2,c2pos)</p>
<p>把c2的c2pos的元素搬到c的pos后</p>
<p>同上</p>
<p>c.splice_after(pos,c2,c2begin,c2end)</p>
<p>把c2的c2begin和c2end之间的元素左闭右开搬到c的pos后</p>
<p>同上</p>
<p>c.sort()</p>
<p>从小到大对c进行排序</p>
<p> </p>
<p>c.sort(op)</p>
<p>以op准则进行排序</p>
<p> </p>
<p>c.merge(c2)</p>
<p>假设c和c2的容器都包含符合op()的已经排序的元素，将c2的元素搬到c，并保证合并后的list依然是已排序的</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.merge(c2,op)</p>
<p>假设c和c2的容器都包含符合op()的已经排序的元素，将c2的元素搬到c，并保证合并后的list依然是符合op的已排序的</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.reserve()</p>
<p>将所有元素反序</p>
<p>不抛出</p>
<p>实例：</p>
<p>#include<br>#include<br>#include<br>#include<br>#include </p>
<p>using namespace std;</p>
<p>void printLists(const string&amp; s, const forward_list&amp; l1, const forward_list&amp; l2)<br>{<br>    cout &lt;&lt; s &lt;&lt; endl;<br>    cout &lt;&lt; “list1:”;<br>    copy(l1.cbegin(), l1.cend(), ostream_iterator(cout, “ “));<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “list2:”;<br>    copy(l2.cbegin(), l2.cend(), ostream_iterator(cout, “ “));<br>    cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main()<br>{<br>    //创建两个空forwardlist<br>    forward_list list1 = { 1,2,3,4 };<br>    forward_list list2 = { 77,88,99 };<br>    printLists(“初始化：”, list1, list2);</p>
<pre><code>//在list2的第一个元素前插入6个新元素
list2.insert\_after(list2.before\_begin(), 99);
list2.push\_front(10);
list2.insert\_after(list2.before\_begin(), &#123; 10,11,12,13 &#125;);
printLists(&quot;6个新元素：&quot;, list1, list2);

//把list2的所有元素插入到list1的开头
list1.insert\_after(list1.before\_begin(), list2.begin(), list2.end());
printLists(&quot;插入结果：&quot;, list1, list2);

//删除第二个元素和在99后面的元素
list2.erase\_after(list2.begin());
list2.erase\_after(find(list2.begin(), list2.end(), 99), list2.end());
printLists(&quot;删除第二个和99之后的&quot;, list1, list2);

//将list1排序并赋值给list2，去除重复元素
list1.sort();
list2 = list1;
list2.unique();
printLists(&quot;排序并去重&quot;, list1, list2);

//合并并排序两个lists到list1
list1.merge(list2);
printLists(&quot;合并：&quot;, list1, list2);
</code></pre>
<p>}</p>
<p>![`刀始<br>list1:1 2 3<br>list2:77 88<br>6수新元素=<br>list1:1 2 3<br>list2:10 11<br>入錯果=<br>listl:10 11<br>list2:10 11<br>list1:1 2 3<br>list2:1 23<br>4<br>99<br>4<br>12<br>12<br>12<br>13<br>13<br>13<br>10 99 77 88 99<br>10 99 77 88 99<br>10 99 77 88 99<br>!]除第二수和99之后的<br>1 2 3 4<br>1 2 3 4<br>listl:10 11<br>list2:10 12<br>*序幷去重<br>12 13 10 99 77 88 99<br>13 10 99<br>口升=<br>list1:<br>list2:<br>1 2<br>4 10 10 11 12 13 77 88 99 99<br>4 10 11 12 13 77 88 99<br>2 3 3 4 4 10 10 10 11 11 12 12<br>13<br>13 77 77 88 88 99 99 99 ](<a target="_blank" rel="noopener" href="https://www.muchenhen.com/wp-content/uploads/2019/11/image-6.png">https://www.muchenhen.com/wp-content/uploads/2019/11/image-6.png</a>)</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/02/stl%EF%BC%9Alist%E5%AE%B9%E5%99%A8/">STL：list容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>list内部结构与array、vector、deque完全不同。list自身有两个指针，用来指向第一个元素和最后一个元素。每个元素都有指针指向前一个和后一个元素，插入删除时改变指针就行。</p>
<p>不支持随机访问，任何位置的插入删除快。插入和删除不会使其他元素的指针，引用和迭代器失效。</p>
<p>list的异常处理方式为，操作成功，或者什么都不发生。</p>
<p>list成员函数显示的与array、vector、deque的区别：</p>
<p>list提供front()、push_front()、pop_front()、back()、push_back()、pop_back()等操作函数</p>
<p>由于不支持随机访问，list不能下标操作符访问，也没有at()函数</p>
<p>list没有内存分配和重新分配的函数，因为没有必要</p>
<p>list有特殊的成员函数用来移动和删除元素，比同名的全局函数速度快。</p>
<h2 id="创建、复制、销毁"><a href="#创建、复制、销毁" class="headerlink" title="创建、复制、销毁"></a>创建、复制、销毁</h2><p>与序列式容器相同，如下表：</p>
<p>操作</p>
<p>结果</p>
<p>list<Elem> c</p>
<p>默认构造</p>
<p>list<Elem> c(c2)</p>
<p>复制构造</p>
<p>list<Elem> c = c2</p>
<p>复制构造</p>
<p>list<Elem> c(rvalue)</p>
<p>move构造</p>
<p>list<Elem> c=crvalue</p>
<p>move构造</p>
<p>list<Elem> c(n)</p>
<p>默认构造一个大小为n的list</p>
<p>list<Elem> c(n,elem)</p>
<p>生成一个有n个元素的list，每个元素都是elem</p>
<p>list<Elem> c(begin,end)</p>
<p>以begin和end的左闭右开区间构造一个list</p>
<p>list<Elem> c(initlist)</p>
<p>以初值列表构造list</p>
<p>list<Elem> c = initlist</p>
<p>同上</p>
<p>c.~list()</p>
<p>销毁所有元素，释放内存</p>
<h2 id="非变动性操作"><a href="#非变动性操作" class="headerlink" title="非变动性操作"></a>非变动性操作</h2><p>操作</p>
<p>效果</p>
<p>c.empty()</p>
<p>返回容器是否为空</p>
<p>c.size()</p>
<p>返回目前容器内元素个数</p>
<p>c.max_size()</p>
<p>返回元素个数的最大可能值</p>
<p>c1 == c2</p>
<p> </p>
<p>!=</p>
<p> </p>
<p>&lt;</p>
<p> </p>
<p>&gt;</p>
<p> </p>
<p>&lt;=</p>
<p> </p>
<p>&gt;=</p>
<p> </p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>操作</p>
<p>效果</p>
<p>c = c2</p>
<p>赋值</p>
<p>c = rv</p>
<p>将右值move给c</p>
<p>c = initlist</p>
<p>初始化表赋给c</p>
<p>c.assign(n,elem)</p>
<p>n个elem赋给c</p>
<p>c.assign(begin,end)</p>
<p>左闭右开赋给c</p>
<p>c.assign(initlist)</p>
<p>初始化表赋给c</p>
<p>c1.swap(c2)</p>
<p>交换c1，c2</p>
<p>swap(c1,c2)</p>
<p>比上面那个慢，全局函数</p>
<h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>不能下标访问，只能用范围for循环，使用特定函数或者迭代器。不支持随机访问，只有front()和back()能直接访问元素。这两个函数不检查范围。</p>
<h2 id="迭代器相关函数"><a href="#迭代器相关函数" class="headerlink" title="迭代器相关函数"></a>迭代器相关函数</h2><p>操作</p>
<p>效果</p>
<p>c.begin()</p>
<p>返回一个双向迭代器指向第一个元素</p>
<p>c.end()</p>
<p>返回指向最后一个元素的双向迭代器</p>
<p>c.cbegin()</p>
<p>第一个的const，c11</p>
<p>c.cend()</p>
<p>第二的const，c11</p>
<p>c.rbegin()</p>
<p>反向的迭代器指向反向迭代的第一个元素</p>
<p>c.rend()</p>
<p>反向的迭代器指向反向迭代的最后一个</p>
<p>c.crbegin()</p>
<p>c11</p>
<p>c.crend()</p>
<p>c11</p>
<h2 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h2><p>list删除元素有特别的remove()成员函数，比全局的remove()函数效率更高，因为只对内部的指针进行操作，不改变元素。</p>
<p>其中rempove_if()函数可以定义移除的元素需要满足的条件，例如：</p>
<p>coll.remove_if([] (int i)</p>
<p>{</p>
<p>return i%2==0;</p>
<p>});</p>
<p>会移除所有偶数。</p>
<h2 id="插入删除函数"><a href="#插入删除函数" class="headerlink" title="插入删除函数"></a>插入删除函数</h2><p>操作</p>
<p>效果</p>
<p>异常处理</p>
<p>c.push_back()</p>
<p>尾插</p>
<p>成功或者没有任何效果</p>
<p>c.pop_back()</p>
<p>尾删，不反悔</p>
<p>不抛出异常</p>
<p>c.push_front()</p>
<p>头插</p>
<p>成功或者没有任何效果</p>
<p>c.pop_front()</p>
<p>头删，不反悔</p>
<p>不抛出异常</p>
<p>c.insert(pos,elem)</p>
<p>指定位置前插入</p>
<p>成功或者没有任何效果</p>
<p>c.insert(pos,n,elem)</p>
<p>指定位置前插入n个elem，返回第一个新元素的位置</p>
<p>成功或者没有任何效果</p>
<p>c.insert(pos,begin,end)</p>
<p>指定位置前插入左闭右开的所有元素，返回第一个新元素位置</p>
<p>成功或者没有任何效果</p>
<p>c.insert(pos,initlist)</p>
<p>指定为之前插入初始化列的所有元素并返回第一个新元素的位置</p>
<p>成功或者没有任何效果</p>
<p>c.emplace(pos,args…)</p>
<p>在pos前插入以args为初值的元素，并返回新元素位置，c11</p>
<p> </p>
<p>c.emplace_back(args…)</p>
<p>上面的函数的后插实现，不返回，c11</p>
<p> </p>
<p>c.emplace_front(args…)</p>
<p>上面的函数的头插实现，不返回，c11</p>
<p> </p>
<p>c.erase(pos)</p>
<p>删除指定位的元素，返回下一个</p>
<p>不抛出异常</p>
<p>c.erase(begin,end)</p>
<p>删除区间</p>
<p>不抛出异常</p>
<p>c.remove(val)</p>
<p>删除所有值为val的元素</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.remove_if(op)</p>
<p>上文讲过了</p>
<p>如上</p>
<p>c.resize(num)</p>
<p>元素数量改为num，如果变多，多出来的默认构造</p>
<p>成功或者没有任何效果</p>
<p>c.resize(num,elem)</p>
<p>如果变多，多出来的为elem</p>
<p>成功或者没有任何效果</p>
<p>c.clear()</p>
<p>删除所有元素</p>
<p>不抛出异常</p>
<p>以下操作不会造成指向成员的迭代器和指针失效：</p>
<p>insert(),emplace(),emplace…(),push_front(),push_back(),pop_front(),pop_back(),erase()</p>
<h2 id="特殊变动性操作"><a href="#特殊变动性操作" class="headerlink" title="特殊变动性操作"></a>特殊变动性操作</h2><p>操作</p>
<p>效果</p>
<p>异常处理</p>
<p>c.unique()</p>
<p>如果存在临近且数值相同的元素，只保留一个</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.unique(op)</p>
<p>如果存在相邻元素满足op，就只保留一个</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.splice(pos,c2)</p>
<p>把c2的所有元素搬到c的pos前</p>
<p>不抛出异常</p>
<p>c.splice(pos,c2,c2pos)</p>
<p>把c2的c2pos的元素搬到c的pos前</p>
<p>同上</p>
<p>c.splice(pos,c2,c2begin,c2end)</p>
<p>把c2的c2begin和c2end之间的元素左闭右开搬到c的pos前</p>
<p>同上</p>
<p>c.sort()</p>
<p>从小到大对c进行排序</p>
<p> </p>
<p>c.sort(op)</p>
<p>以op准则进行排序</p>
<p> </p>
<p>c.merge(c2)</p>
<p>假设c和c2的容器都包含符合op()的已经排序的元素，将c2的元素搬到c，并保证合并后的list依然是已排序的</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.merge(c2,op)</p>
<p>假设c和c2的容器都包含符合op()的已经排序的元素，将c2的元素搬到c，并保证合并后的list依然是符合op的已排序的</p>
<p>元素比较不抛出异常，这个函数就不抛出异常</p>
<p>c.reserve</p>
<p>将所有元素反序</p>
<p>不抛出</p>
<h2 id="list实例："><a href="#list实例：" class="headerlink" title="list实例："></a>list实例：</h2><p>#include<br>#include<br>#include<br>#include </p>
<p>using namespace std;</p>
<p>void printLists(const list&amp; l1, const list&amp; l2)<br>{<br>    cout &lt;&lt; “list1:”;<br>    copy(l1.cbegin(), l2.cend(), ostream_iterator(cout, “ “));<br>    cout &lt;&lt; endl &lt;&lt; “list2:”;<br>    copy(l2.cbegin(), l2.cend(), ostream_iterator(cout, “ “));<br>    cout &lt;&lt; endl &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    //创建两个空链表<br>    list list1, list2;</p>
<pre><code>//填充元素
for (int i = 0; i &lt; 6; ++i)
&#123;
    list1.push\_back(i);
    list2.push\_front(i);
&#125;
printLists(list1, list2);

//把list1的所有元素插入到list2的第一个值为3的元素前面
//find()返回一个指向第一个值为3的元素的迭代器
list2.splice(find(list2.begin(), list2.end(), //定义位置
    3),
    list1);//源链表

printLists(list1, list2);

//将list2的第一个元素移到最后
list2.splice(list2.end(),    //定义位置
             list2,            //源链表
             list2.begin());//初始位置

printLists(list1, list2);

//排序list2，将其赋值给list1，并删除list1中重复元素
list2.sort();
list1 = list2;
list2.unique();
printLists(list1, list2);

//将同样排过序的list2合并到list1
list1.merge(list2);
printLists(list1, list2);
</code></pre>
<p>}</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-5.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/01/chapter-4-d3d%E5%88%9D%E5%A7%8B%E5%8C%96-4-1-%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/">Chapter 4 D3D初始化 4.1 前置技能</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/DirectX12/">DirectX12</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a></span><div class="content"><p>本文相关知识点：<br>D3D12总览<br>COM<br>Textures Formats<br>交换链和页面翻转<br>深度缓冲</p>
<p>这一章学习什么是Direct3D，以及如何初始化它，为3D绘图做准备。还介绍了基本的Direct3D主题，如表面、像素格式、页面翻转、深度缓冲和多采样还，如何使用性能计数器度量时间，使用它来计算每秒呈现的帧数。还提供了一些调试Direct3D应用程序的技巧。</p>
<p>Direct3D的初始化过程要求熟悉一些基本的Direct3D类型和基本的图形概念;本章的第一节和第二节讨论这些要求。然后详细介绍初始化Direct3D所需的步骤。引入实时图形应用程序所需的精确计时和时间度量。</p>
<p>目的:</p>
<ol>
<li> 基本了解Direct3D在3D硬件编程中的作用。</li>
<li> 了解COM在Direct3D中扮演的角色。</li>
<li> 学习基本的图形概念，如2D图像如何存储，页面翻转，深度缓冲，多采样，以及CPU和GPU如何交互。</li>
<li> 学习如何使用性能计数器函数获得高分辨率计时器读数。</li>
<li> 了解如何初始化Direct3D。</li>
<li>  熟悉本书所有演示使用的应用程序框架的一般结构。</li>
</ol>
<h2 id="4-1-1-Direct3D-12-概述"><a href="#4-1-1-Direct3D-12-概述" class="headerlink" title="4.1.1 Direct3D 12 概述"></a>4.1.1 Direct3D 12 概述</h2><p>D3D是一个低级图形API，用于控制和编程GPU，用硬件加速渲染。</p>
<h2 id="4-1-2-COM"><a href="#4-1-2-COM" class="headerlink" title="4.1.2 COM"></a>4.1.2 COM</h2><p>Component Object Model 简称COM，是一种允许DirectX独立于编程语言并具有向后兼容性的技术。通常将COM对象称为接口，可以将其视为c++类来使用。</p>
<h2 id="4-1-3-纹理格式"><a href="#4-1-3-纹理格式" class="headerlink" title="4.1.3 纹理格式"></a>4.1.3 纹理格式</h2><p>一般的2D纹理存储图像的对应像素的颜色值。但是纹理可以有更广泛的用途，一维纹理就像数据元素的一维数组，二维纹理就像数据元素的二维数组，三维纹理就相对于三维数组。GPU可以对其进行特殊操作，比如滤波和多重采样。</p>
<p>注意，纹理不能存储任意类型的数据。只能存储右DXGI_FORMAT枚举类型。</p>
<p>下面有几个例子：</p>
<ol>
<li> DXGI_FORMAT_R32G32B32_FLOAT: 每个元素有三个32位浮点组件。</li>
<li> DXGI_FORMAT_R16G16B16A16_UNORM: 每个元素有四个映射到[0,1]范围的16位组件。</li>
<li> DXGI_FORMAT_R32G32_UINT: 每个元素都有两个32位无符号整数组件。</li>
<li> DXGI_FORMAT_R8G8B8A8_UNORM: 每个元素有四个映射到[0,1]范围的8位无符号组件。</li>
<li> DXGI_FORMAT_R8G8B8A8_SNORM: 每个元素有四个映射到[- 1,1]范围的8位有符号组件。</li>
<li> DXGI_FORMAT_R8G8B8A8_SINT: 每个元素有四个映射到[- 128,127]范围的8位有符号整数组件。</li>
<li> DXGI_FORMAT_R8G8B8A8_UINT: 每个元素有四个映射到[0,255]范围的8位无符号整数组件。</li>
</ol>
<p>RGBA分别代表红绿蓝，透明度。虽然这些类型名字是和颜色有关的，但是并不意味着必须存储颜色信息。比如：</p>
<p>DXGI_FORMAT_R32G32B32_FLOAT</p>
<p>是可以存储任何3D向量的。</p>
<h2 id="4-1-4-The-Swap-China-and-Page-Flipping"><a href="#4-1-4-The-Swap-China-and-Page-Flipping" class="headerlink" title="4.1.4 The Swap China and Page Flipping"></a>4.1.4 The Swap China and Page Flipping</h2><p>交换链和页面翻转</p>
<p>为了避免动画的闪烁，使观察者（玩家）只看到渲染好的画面，并且看不到每个画面渲染的过程，就用到了一个后台缓冲，即每个画面在渲染完成之前是在一个用户看不到的后台进行渲染，整个画面完成后才放到屏幕上。所以，硬件将会维护两个缓冲区，一个为前端，一个为后端。前缓冲区储存当前显示在屏幕上的图像数据，后缓冲区是下一帧的动画。下一帧渲染好后，前后缓冲区角色互换，继续下一帧。整个过程如图：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image.png" alt="Front Buffer Ptr 
Back Buffer Ptr 
Frame n 
Buffer A 
Buffer B 
Frame n+l 
Buffer B 
Buffer A 
Frame n+2 
Buffer A 
Buffer B "></p>
<p>前后缓冲区形成了交换链。</p>
<p>D3D中交换链是 IDXGISwapChain 接口。该接口存储前后缓冲区的纹理数据，并提供调整缓冲区大小的方法。</p>
<p>IDXGISwapChain::ResizeBuffers</p>
<p>IDXGISwapChain::Present</p>
<p>使用两个缓冲区称为双缓冲。可以使用两个以上的缓冲区，使用三个就是三缓存，一般两个缓冲区就够了。</p>
<h2 id="4-1-5-深度缓冲"><a href="#4-1-5-深度缓冲" class="headerlink" title="4.1.5 深度缓冲"></a>4.1.5 深度缓冲</h2><p>深度缓冲是纹理的一个例子。不存储颜色信息，存储的是特定像素的深度信息。与后缓冲区的像素一一对应。深度信息的0.0表示离查看器最近的，1.0表示最远。</p>
<p>如图一个简单的场景，存在遮挡关系，需要让DirectX确定像素的前后关系，就是用了深度缓冲或Z-buffer的技术。使用深度缓冲时，绘制对象的顺序就不重要了。</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-1.png"></p>
<p>下图形象展示了深度缓冲的原理：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-2.png" alt="View Window 
Eye 
Eye 
View Window "></p>
<p>再进行任何渲染前，深度缓冲区会被清除为默认值，通常是1.0，即可行的深度最大值。后缓冲区也会重置为默认颜色。对于图中的像素点P，我们一看就知道渲染成P1是正确的，但是计算机不知道。所以，深度缓冲区的存在，可以让计算机知道P1挡住了P2和P3。深度信息会被标准化到0.0到1.0之间。</p>
<p>操作</p>
<p>P</p>
<p>d</p>
<p>描述</p>
<p>清除操作</p>
<p>黑色</p>
<p>1.0</p>
<p>初始化像素颜色和对应深度值</p>
<p>画圆柱</p>
<p>P3</p>
<p>d3</p>
<p>由于d3&lt;=d（1.0），所以更新信息，P=P3，d=d3</p>
<p>画球</p>
<p>P1</p>
<p>d1</p>
<p>由于d1&lt;=d（d1），更新，P=P1，d=d1</p>
<p>画圆锥</p>
<p>P1</p>
<p>d1</p>
<p>d2&gt;d（d1），不更新信息</p>
<p>上表是上面那个图的大概的操作过程。每一个像素点，遇到深度较小的时候会更新，否则不更新。</p>
<p>深度缓冲是一个纹理，需要有特定的存储格式：</p>
<ol>
<li> DXGI_FORMAT_D32_FLOAT_S8X24_UINT: 指定32位浮点深度缓冲区，8位(无符号整数)预留给模板缓冲区映射到[0,255]范围，24位不用于填充。</li>
<li> DXGI_FORMAT_D32_FLOAT: 指定一个32位浮点深度缓冲区。</li>
<li> DXGI_FORMAT_D24_UNORM_S8_UINT: 指定一个映射到[0,1]范围的无符号24位深度缓冲区，并为模板缓冲区保留8位(无符号整数)映射到[0,255]范围。该缓冲区可以称为模板缓冲区，会在第11章详述。</li>
<li> DXGI_FORMAT_D16_UNORM:指定映射到[0,1]范围的无符号16位深度缓冲区。</li>
</ol>
<h2 id="4-1-6-Resources-and-Descriptors"><a href="#4-1-6-Resources-and-Descriptors" class="headerlink" title="4.1.6 Resources and Descriptors"></a>4.1.6 Resources and Descriptors</h2><p>资源和描述符</p>
<p>渲染过程中，GPU会不断的写入和读取资源，在draw命令发出之前还需要绑定或者链接资源到即将要渲染的drawcall的渲染管道。有些资源每次渲染会变化，就需要更新绑定信息，但是GPU资源不是直接绑定。资源是通过描述符对象引用的，可以将其视为向GPU描述资源的轻量级结构，本质上，它是一种间接的层次;给定一个资源描述符，GPU可以获取实际的资源数据，并知道它的必要信息。</p>
<p>使用描述符的目的是让资源在GPU通用内存块上保持通用，这样在渲染管道的不同阶段都可以使用。</p>
<h2 id="4-1-7-多重采样"><a href="#4-1-7-多重采样" class="headerlink" title="4.1.7 多重采样"></a>4.1.7 多重采样</h2><p>抗锯齿/多重采样MSAA</p>
<p>显示器像素不是无穷小的，所有会有下面的这种情况：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-3.png"></p>
<p>上面是走样，下面是抗锯齿，通过采样和相邻像素来生成一个像素的最终颜色，使图像更平滑。</p>
<p>显示器分辨率增加，减小像素点的大小也可以显著减少走样现象。但是好的显示器比较贵。所以可以应用超采样技术（SSAA）。原理是让后缓冲区和深度缓冲区为屏幕分辨率的4倍大小，交换前后缓冲时，进行向下采样，每4个像素点的颜色平均成一个。超采样通过软件分辨率来实现。</p>
<p>但是超采样对内存和像素处理又多了较高的要求，满足条件的硬件也不是很便宜的。D3D支持一种折中的反锯齿拘束，称为多重采样。这种技术不用对每一个像素进行计算，它计算一次中心像素的颜色，然后基于可视性和覆盖性，将得到的信息分享给其他子像素（使一次计算，受惠4个像素，从而减少开销）。</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/11/image-4.png"></p>
<h2 id="4-1-8-DirectX中的MSAA"><a href="#4-1-8-DirectX中的MSAA" class="headerlink" title="4.1.8 DirectX中的MSAA"></a>4.1.8 DirectX中的MSAA</h2><p>DXGI_SAMPLE_DESC</p>
<p>该结构有两个成员，定义如下:</p>
<p>typedef struct DXGI_SAMPLE_DESC {<br>    UINT Count;<br>    UINT Quality；<br>} DXGI_SAMPLE_DESC;</p>
<p>Count成员指定每像素采样的数量，而Quality成员用于指定所需的质量级别(“质量级别”的含义可能因硬件制造商而异)。质量等级的范围取决于纹理格式和每像素采样的数量。</p>
<p>可以使用ID3D12Device::CheckFeatureSupport方法查询给定纹理格式的质量级别数量和样本数量。</p>
<h2 id="4-1-9Feature-Levels"><a href="#4-1-9Feature-Levels" class="headerlink" title="4.1.9Feature Levels"></a>4.1.9Feature Levels</h2><p>特征级别</p>
<p>Direct3D 11引入了特征级别的概念(在代码中由D3D_FEATURE_LEVEL枚举类型表示)，它大致对应于从版本9到版本11的各种Direct3D版本:</p>
<p>enum D3D_FEATURE_LEVEL {<br>    D3D_FEATURE_LEVEL_9_1 = 0x9100,<br>    D3D_FEATURE_LEVEL_9_2 = 0x9200,<br>    D3D_FEATURE_LEVEL_9_3 = 0x9300,<br>    D3D_FEATURE_LEVEL_10_0 = 0xa000,<br>    D3D_FEATURE_LEVEL_10_1 = 0xa100,<br>    D3D_FEATURE_LEVEL_11_0 = 0xb000,<br>    D3D_FEATURE_LEVEL_11_1 = 0xb100<br>}D3D_FEATURE_LEVEL;</p>
<p>特征级别定义了一组严格的功能。例如，一个支持feature level 11的GPU必须支持整个Direct3D 11功能集。如果用户的硬件不支持某个特征级别，则应用程序可以退回到旧的特征级别。</p>
<h2 id="4-1-10-DirectX-图形基础设施"><a href="#4-1-10-DirectX-图形基础设施" class="headerlink" title="4.1.10 DirectX 图形基础设施"></a>4.1.10 DirectX 图形基础设施</h2><p>DirectX Graphics Infrastructure (DXGI) 是一个与Direct3D一起使用的API。基本思想是，一些与图形相关的任务对于多个图形api是通用的。例如，2D渲染API和3D渲染API一样需要交换链和页面翻转来获得平滑的动画;因此，交换链接口IDXGISwapChain(4.1.4)实际上是DXGI API的一部分。DXGI处理其他常见的图形功能，如全屏模式转换、枚举图形系统信息(如显示适配器、监视器和支持的显示模式(分辨率、刷新率等);它还定义了各种受支持的表面格式(DXGI_FORMAT)。</p>
<p>简要描述了一些DXGI概念和接口，将在Direct3D初始化过程中使用。DXGI的一个关键接口是IDXGIFactory接口，它主要用于创建IDXGISwapChain接口和枚举显示适配器。显示适配器实现图形化功能。通常，显示适配器是一个物理硬件(例如，显卡);但是，系统也可以有一个软件显示适配器来模拟硬件图形功能。一个系统可以有多个适配器(例如，如果它有多个显卡)。适配器由IDXGIAdapter接口表示。可以用以下代码枚举系统上的所有适配器:</p>
<p>void D3DApp::LogAdapters()<br>{<br>    UINT i = 0; IDXGIAdapter* adapter = nullptr;<br>    std::vector adapterList;<br>    while (mdxgiFactory-&gt;EnumAdapters(i, &amp;adapter) !=DXGI_ERROR_NOT_FOUND)<br>    {<br>        DXGI_ADAPTER_DESC desc; adapter-&gt;GetDesc(&amp;desc);<br>        std::wstring text = L”***Adapter: “;<br>        text += desc.Description; text += L”\n”;<br>        OutputDebugString(text.c_str());<br>        adapterList.push_back(adapter);<br>        ++i;<br>    }<br>    for (size_t i = 0; i &lt; adapterList.size(); ++i)<br>    {<br>        LogAdapterOutputs(adapterList[i]);<br>        ReleaseCom(adapterList[i]);<br>    }<br>}</p>
<p>下面是这个方法的输出示例：</p>
<p>***Adapter: NVIDIA GeForce GTX 760</p>
<p>***Adapter: Microsoft Basic Render Driver</p>
<p>Microsoft Basic Render Driver在Win8及以上版本中都有。</p>
<p>一个系统可以有多个显示器。显示器是显示输出的一个例子。输出由IDXGIOutput接口表示。每个适配器都与输出列表相关联。例如，考虑一个具有两个显卡和三个显示器的系统，其中两个显示器连接到一个显卡，而第三个显示器连接到另一个显卡。在本例中，一个适配器有两个与之关联的输出，而另一个适配器有一个与之关联的输出。我们可以用以下代码枚举与适配器关联的所有输出：</p>
<p>void D3DApp::LogAdapterOutputs(IDXGIAdapter* adapter)<br>{<br>    UINT i = 0; IDXGIOutput* output = nullptr;<br>    while (adapter-&gt;EnumOutputs(i, &amp;output) != DXGI_ERROR_NOT_FOUND)<br>    {<br>        DXGI_OUTPUT_DESC desc; output-&gt;GetDesc(&amp;desc);<br>        std::wstring text = L”***Output: “;<br>        text += desc.DeviceName; text += L”\n”;<br>        OutputDebugString(text.c_str());<br>        LogOutputDisplayModes(output, DXGI_FORMAT_B8G8R8A8_UNORM);<br>        ReleaseCom(output);<br>        ++i;<br>    }<br>}</p>
<p>注意，根据文档，“Microsoft Basic Render Driver”没有显示输出。每个监视器都支持一组显示模式。显示模式是指DXGI_MODE_DESC中的以下数据:</p>
<p>typedef struct DXGI_MODE_DESC {<br>    UINT Width; // Resolution width UINT Height;<br>                // Resolution height DXGI_RATIONAL RefreshRate; DXGI_FORMAT Format;<br>                // Display format DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;<br>                // Progressive<br>    vs.interlaced DXGI_MODE_SCALING Scaling;<br>    // 图像延伸到显示器上的方法。<br>} DXGI_MODE_DESC;<br>typedef struct DXGI_RATIONAL {<br>    UINT Numerator;<br>    UINT Denominator;<br>} DXGI_RATIONAL;<br>typedef enum DXGI_MODE_SCANLINE_ORDER {<br>    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0,<br>    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1,<br>    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2,<br>    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3<br>} DXGI_MODE_SCANLINE_ORDER;<br>typedef enum DXGI_MODE_SCALING {<br>    DXGI_MODE_SCALING_UNSPECIFIED = 0,<br>    DXGI_MODE_SCALING_CENTERED = 1,<br>    DXGI_MODE_SCALING_STRETCHED = 2<br>} DXGI_MODE_SCALING;</p>
<p>固定显示模式格式，可以得到一个列表的所有支持的显示模式的输出支持的格式与以下代码:</p>
<p>下面是这段代码的一些输出示例：</p>
<p>***Output: <a href="file://./DISPLAY2">\\.\DISPLAY2</a></p>
<p> …</p>
<p>Width = 1920 Height = 1080 Refresh = 59950/1000</p>
<p>Width = 1920 Height = 1200 Refresh = 59950/1000</p>
<p>在进入全屏模式时，枚举显示模式尤为重要。为了获得最佳的全屏性能，指定的显示模式(包括刷新率)必须与监视器支持的显示模式完全匹配。指定枚举显示模式保证了这一点。</p>
<p>更多资料：</p>
<p> DXGI Overview:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi?redirectedfrom=MSDN</a></p>
<p>DirectX Graphics Infrastructure:</p>
<p>Best Improvements:</p>
<p><a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee417025(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ee417025(v=vs.85).aspx</a></p>
<p>DXGI 1.4 Improvements:</p>
<p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt427784%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/mt427784%28v=vs.85%29.aspx</a></p>
<h2 id="4-1-11检查特性支持"><a href="#4-1-11检查特性支持" class="headerlink" title="4.1.11检查特性支持"></a>4.1.11检查特性支持</h2><p>使用ID3D12Device::CheckFeatureSupport方法来检查当前图形驱动程序的多采样支持。这只是可以用这个函数检查的一个特性支持。该方法的原型如下:</p>
<p>HRESULT ID3D12Device::CheckFeatureSupport(</p>
<p>D3D12_FEATURE Feature,</p>
<p> void *pFeatureSupportData,</p>
<p>UINT FeatureSupportDataSize);</p>
<p>译文：</p>
<p>1. Feature: D3D12_FEATURE枚举类型的一个成员，标识我们想要检查的特性的类型:</p>
<ol>
<li> D3D12_FEATURE_D3D12_OPTIONS:检查对各种Direct3D 12特性的支持。</li>
<li> D3D12_FEATURE_ARCHITECTURE:检查对硬件架构特性的支持。</li>
<li> D3D12_FEATURE_FEATURE_LEVELS:检查支持特性级别</li>
<li> 4D3D12_FEATURE_FORMAT_SUPPORT:检查给定纹理格式的特性支持(例如，该格式是否可以用作渲染目标，该格式是否可以与混合一起使用)。</li>
<li> D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS:检查多采样特性是否支持。</li>
</ol>
<p>2.pFeatureSupportData:指向数据结构的指针，用于检索特性支持信息。使用的结构类型取决于指定的特征参数:</p>
<ul>
<li>  D3D12_FEATURE_D3D12_OPTIONS—&gt;D3D12_FEATURE_DATA_D3D12_OPTIONS.</li>
<li>  D3D12_FEATURE_ARCHITECTURE—&gt;D3D12_FEATURE_DATA_ARCHITECTURE</li>
<li>  D3D12_FEATURE_FEATURE_LEVELS—&gt;D3D12_FEATURE_DATA_FEATURE_LEVELS.</li>
<li>  D3D12_FEATURE_FORMAT_SUPPORT—&gt;D3D12_FEATURE_DATA_FORMAT_SUPPORT.</li>
<li>  D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS—&gt;D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS</li>
</ul>
<p>.FeatureSupportDataSize:参数传递到pFeatureSupportData的数据结构的大小。</p>
<p>ID3D12Device::CheckFeatureSupport函数检查对许多特性的支持，并且是高级的特性;有关每个特性结构的数据成员的详细信息，请参阅SDK文档。下面有一个例子展示了如何检查支持的特性级别(§4.1.9):</p>
<p>typedef struct D3D12_FEATURE_DATA_FEATURE_LEVELS<br>{ UINT NumFeatureLevels;<br>const D3D_FEATURE_LEVEL* pFeatureLevelsRequested;<br>D3D_FEATURE_LEVEL MaxSupportedFeatureLevel;<br>} D3D12_FEATURE_DATA_FEATURE_LEVELS;</p>
<p>D3D_FEATURE_LEVEL featureLevels[3] =<br>{<br>D3D_FEATURE_LEVEL_11_0, // First check D3D 11 support 首先检查是否支持11<br>D3D_FEATURE_LEVEL_10_0, // Next, check D3D 10 support 再检查是否支持10<br>D3D_FEATURE_LEVEL_9_3   // Finally, check D3D 9.3 support 最后检查9.3<br>};<br>D3D12_FEATURE_DATA_FEATURE_LEVELS featureLevelsInfo;<br>featureLevelsInfo.NumFeatureLevels = 3;<br>featureLevelsInfo.pFeatureLevelsRequested = featureLevels;<br>md3dDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FEATURE_LEVELS, &amp;featureLevelsInfo,sizeof(featureLevelsInfo));</p>
<h2 id="4-1-12-Residency"><a href="#4-1-12-Residency" class="headerlink" title="4.1.12 Residency"></a>4.1.12 Residency</h2><p>驻留期</p>
<p>一个复杂的游戏会使用大量的资源，比如纹理和3D网格，但是GPU并不总是需要这些资源。</p>
<p>在Direct3D 12中，应用程序管理资源驻留(一个资源是否在GPU内存中)的方法是从GPU内存中清除资源，然后根据需要使它们再次驻留在GPU上。基本的想法是最小化应用程序使用的GPU内存，因为可能没有足够的内存来存储整个游戏的所有资源，或者用户运行的其他应用程序需要GPU内存。作为一个性能说明，应用程序应该避免在很短的时间内交换相同的GPU内存中的资源，因为这样做有开销。游戏关卡或者区域的改变是改变资源驻留时间的应用场景。</p>
<p>默认情况下，当一个资源被创建时，它是常驻的，当资源被销毁时就会GPU中清除。当然有手动控制资源常驻的方法：</p>
<p>HRESULT ID3D12Device::MakeResident(UINT NumObjects, ID3D12Pageable* const* ppObjects);</p>
<p>HRESULT ID3D12Device::Evict(UINT NumObjects, ID3D12Pageable* const* ppObjects);</p>
<p>对于这两种方法，第二个参数是ID3D12Pageable资源的数组，第一个参数是数组中的资源数量。</p>
<p>更多参考：</p>
<p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt186622%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/mt186622%28v=vs.85%29.aspx</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/31/stl%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/">STL：deque容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>发音</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/deque.png" alt="deque 
/dek/ O /dEk/ O "></p>
<p>和vector相似，但是可以在两端进行插入删除，支持随机访问。</p>
<p>为了实现两端的插入和删除，deque的内存实现为一组独立区块，第一区块朝一个方向扩展，最末区块朝另一个方向扩展。</p>
<p>需要头文件<deque></p>
<p>位于命名空间std，定义如下：</p>
<p>template &lt;class Type, class Allocator =allocator<Type>&gt;<br>class deque</p>
<p>参数：</p>
<p>第一个参数是要存储在 deque 中的元素数据类型</p>
<p>第二个参数为所存储分配器对象的类型，该分配器对象封装有关 deque 的内存分配和解除分配的详细信息。 此参数是可选的, 默认值为 &lt;分配器类型 &gt; 。</p>
<p>deque与vector功能的差异</p>
<ul>
<li>  deque元素访问和迭代器动作稍慢，因为有一个间接过程</li>
<li>  deque的迭代器一定是智能指针</li>
<li>  在内存有限制的系统内deque可以用多个区块所以能有更多元素</li>
<li>  deque的插入和删除操作，除了在头尾两端，都会让其中元素的任何已存在的引用，迭代器和指针失效。</li>
<li>  deque的内存重分配优于vector，不用复制全部元素。</li>
<li>  deque会释放不再使用的内存块。</li>
</ul>
<p>可以优先选用deque的场景</p>
<ol>
<li> 需要在两端插入删除</li>
<li> 不需要指向容器内元素</li>
<li> 有需求要求不再使用的元素释放（c++标准不保证此项）</li>
</ol>
<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p>操作</p>
<p>效果</p>
<p>deque<Elem> c</p>
<p>默认构造，空的queue</p>
<p>deque<Elem> c(c2)</p>
<p>复制构造</p>
<p>deque<Elem> c = c2</p>
<p>同上</p>
<p>deque<Elem> c(rvalue)</p>
<p>move构造，c11</p>
<p>deque&lt;<Elem> c = rvalue</p>
<p>同上，c11</p>
<p>deque<Elem> c(n)</p>
<p>默认构造生成一个大小为n的queue</p>
<p>deque&lt;Elem c(n,elem)</p>
<p>初始化一个大小为n，每个元素都是elem的queue</p>
<p>deque<Elem> c(begin,end)</p>
<p>初始化一个queue，元素是begin和end的范围</p>
<p>deque<Elem> c(initlist)</p>
<p>以初始化列进行初始化，c11</p>
<p>deque<Elem> c = initlist</p>
<p>同上</p>
<p>c.~deque()</p>
<p>销毁所有元素，释放内存</p>
<p>与vector不同的两点操作：</p>
<ol>
<li> 不提供容量操作，如capacity()，sreserve()</li>
<li> deque直接提供函数完成头部的插入删除，push_front()，pop_front()</li>
</ol>
<p>c++11添加了函数shrink_to_fit()，缩小内存以匹配元素个数，但没有强制力。会释放掉deque本身不会释放的用于存储指针的空间。</p>
<h2 id="非变动性操作"><a href="#非变动性操作" class="headerlink" title="非变动性操作"></a>非变动性操作</h2><p>操作</p>
<p>效果</p>
<p>c.empty()</p>
<p>返回是否为空</p>
<p>c.size()</p>
<p>返回当前容器内元素数量</p>
<p>c.max_size()</p>
<p>返回容器最大的可能元素数量</p>
<p>c.shrink_to_fit()</p>
<p>减少容器内存来符合元素数量，c11</p>
<p>c1 == c2</p>
<p> </p>
<p>!=</p>
<p> </p>
<p>&gt;</p>
<p> </p>
<p>&lt;</p>
<p> </p>
<p>&gt;=</p>
<p> </p>
<p>&lt;=</p>
<p> </p>
<p>c[index]</p>
<p>返回索引所指的元素</p>
<p>c.at(index)</p>
<p>会检查范围，返回索引指向的元素，超过范围会抛出异常</p>
<p>c.front()</p>
<p>返回第一个元素，不检查是否存在第一个元素</p>
<p>c.back()</p>
<p>返回最后一个元素，也不检查</p>
<p>c.begin()</p>
<p>返回指向第一个元素的迭代器</p>
<p>c.end()</p>
<p>返回指向最后一个元素的迭代器</p>
<p>c.cbegin()</p>
<p>返回一个const的指向第一的迭代器，c11</p>
<p>c.cend()</p>
<p>const，最后，c11</p>
<p>c.rbegin()</p>
<p>看例子，返回该deque的反向的deque的第一个元素的迭代器</p>
<p>c.rend()</p>
<p>和上面那个类比一下</p>
<p>c.crbegin()</p>
<p>上上面那个再加个const</p>
<p>c.crend()</p>
<p> </p>
<p>c.rbegin()</p>
<p>// deque_rbegin.cpp<br>// compile with: /EHsc<br>#include #include int main()<br>{<br>    using namespace std;<br>    deque c1;<br>    deque ::iterator c1_Iter;<br>    deque ::reverse_iterator c1_rIter;</p>
<pre><code>// If the following line had replaced the line above, an error
// would have resulted in the line modifying an element
// (commented below) because the iterator would have been const
// deque ::const\_reverse\_iterator c1\_rIter;

c1.push\_back(10);
c1.push\_back(20);
c1.push\_back(30);

c1\_rIter = c1.rbegin();
cout &lt;&lt; &quot;deque中的最后一个元素是&quot; &lt;&lt; \*c1\_rIter &lt;&lt; &quot;.&quot; &lt;&lt; endl;

cout &lt;&lt; &quot;deque中都有这些元素: &quot;;
for (c1\_Iter = c1.begin(); c1\_Iter != c1.end(); c1\_Iter++)
    cout &lt;&lt; \*c1\_Iter &lt;&lt; &quot; &quot;;
cout &lt;&lt; endl;

// 可以使用rbegin以相反的顺序遍历deque
cout &lt;&lt; &quot;反序的deque是: &quot;;
for (c1\_rIter = c1.rbegin(); c1\_rIter != c1.rend(); c1\_rIter++)
    cout &lt;&lt; \*c1\_rIter &lt;&lt; &quot; &quot;;
cout &lt;&lt; endl;

c1\_rIter = c1.rbegin();
\*c1\_rIter = 40;  // 如果如上所述声明了const\_reverse迭代器，则会导致错误
cout &lt;&lt; &quot;现在deque的最后一个元素是 &quot; &lt;&lt; \*c1\_rIter &lt;&lt; &quot;.&quot; &lt;&lt; endl;
</code></pre>
<p>} </p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/deque%E8%BE%93%E5%87%BA.png" alt="deque 的 后 一 《 元 素 是 30 ． 
de “ 都 者 这 些 元 素 ： 10 20 30 
30 20 10 
在 qu 的 后 一 个 元 素 是 "></p>
<p>是很好理解的</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>除了at()，没有任何成员函数检查索引或者迭代器是否有效</p>
<p>元素的插入和删除可能导致内存重新分配，会使所有的指向deque元素的指针，索引和迭代器失效，除非是在头尾进行该操作，在前面已经强调过了。</p>
<p>另外，即使是在头尾进行插入删除也会使原本指向首尾的迭代器失效。</p>
<h2 id="变动性操作"><a href="#变动性操作" class="headerlink" title="变动性操作"></a>变动性操作</h2><p>操作</p>
<p>效果</p>
<p>c = c2</p>
<p>赋值</p>
<p>c = rv</p>
<p>将右值rv的所有元素move assign的方式给c，c11   </p>
<p>c = initlist</p>
<p>将初值列的值赋给c</p>
<p>c.assign(n,elem)</p>
<p>将n个elem的值赋给c的对应n个元素</p>
<p>c.assign(begin,end)</p>
<p>将[begin,end)的元素给c</p>
<p>c.assign(initlist)</p>
<p>将初值列的所有元素给c</p>
<p>c1.swap(c2)</p>
<p>c1，c2置换</p>
<p>swap(c1,c2)</p>
<p>同上，全局函数</p>
<p>c.push_back(elem)</p>
<p>在尾部插入elem</p>
<p>c.pop_back()</p>
<p>移除尾部的元素，不返回</p>
<p>c.push_front(elem)</p>
<p>在头部插入一个elem</p>
<p>c.pop_front()</p>
<p>移除头部的元素，不返回</p>
<p>c.insert(pos,elem)</p>
<p>在pos的位置前插入elem，并返回新元素的位置</p>
<p>c.insert(pos,n,elem)</p>
<p>在pos前插入n个elem，并返回第一个新元素的位置</p>
<p>c.insert(pos,begin,end)</p>
<p>在pos前插入范围并返回第一个元素的位置</p>
<p>c.insert(pos,initlist)</p>
<p>在pos前插入initlist内的元素并返回第一个新元素的位置，c11</p>
<p>c.emplace(pos,args…)</p>
<p>在pos前插入一个以args为初值的元素，并返回新元素的位置，C11</p>
<p>c.emplace_back(args…)</p>
<p>在末尾附加一个以args为初值的元素，不返回，C11</p>
<p>c.emplace_front(args…)</p>
<p>在起点前插入一个以args为初值的元素，不返回，C11</p>
<p>c.erase(pos)</p>
<p>移除pos位置的元素，并返回下一个元素的位置</p>
<p>c.erase(begin,end)</p>
<p>移除begin和end范围内的元素，返回下一个元素位置</p>
<p>c.resize(num)</p>
<p>将元素数量改为num，如果size变大，多出的位置进行默认构造</p>
<p>c.resize(num,elem)</p>
<p>和上面的类似，但是多出来的元素是elem</p>
<p>c.clear()</p>
<p>清空容器</p>
<h2 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h2><p>#include #include #include #include #include using namespace std;</p>
<p>int main()<br>{<br>    //初始化一个空的deque，元素类型为string<br>    deque coll;</p>
<pre><code>//插入几个元素
coll.assign(3, string(&quot;string&quot;));
coll.push\_back(&quot;last string&quot;);
coll.push\_front(&quot;first string&quot;);

//打印
copy(coll.cbegin(), coll.cend(), ostream\_iterator(cout, &quot;\\n&quot;));
cout &lt;&lt; endl;

//移除第一个和最后一个元素
coll.pop\_front();
coll.pop\_back();

//在除了第一个元素前的每一个位置插入“another”
for (unsigned i = 1; i &lt; coll.size(); ++i)
&#123;
    coll\[i\] = &quot;another&quot; + coll\[i\];
&#125;

//将容器数量变为4个
coll.resize(4, &quot;resized string&quot;);

//打印元素
copy(coll.cbegin(), coll.cend(), ostream\_iterator(cout, &quot;\\n&quot;));

return 0;
</code></pre>
<p>}</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/30/dx12%E9%BE%99%E4%B9%A6part%E2%85%A0chapter-3-%E5%8F%98%E6%8D%A2/">DX12龙书PartⅠChapter 3 变换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/DirectX12/">DirectX12</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a></span><div class="content"><h2 id="Chapter-3-TRANSFORMATIONS"><a href="#Chapter-3-TRANSFORMATIONS" class="headerlink" title="Chapter 3 TRANSFORMATIONS"></a>Chapter 3 TRANSFORMATIONS</h2><p>本章的数学部分只总结结论，具体过程会总结在别的文章</p>
<p>几何变换的例子有平移、旋转和缩放。在这一章中，我们建立了矩阵方程，它可以用来转换三维空间中的点和向量。</p>
<p>目的:</p>
<ol>
<li> 了解如何用矩阵表示线性和仿射变换。</li>
<li> 学习用于缩放、旋转和转换几何图形的坐标转换。</li>
<li> 了解如何通过矩阵-矩阵乘法将多个变换矩阵组合成一个净变换矩阵。</li>
<li> 找出如何将坐标从一个坐标系转换到另一个坐标系，以及如何用矩阵表示坐标变换的变化。</li>
<li> 熟悉用于构造转换矩阵的DirectX数学库提供的函数子集。</li>
</ol>
<h2 id="3-1线性变换"><a href="#3-1线性变换" class="headerlink" title="3.1线性变换"></a>3.1线性变换</h2><h3 id="3-1-1定义"><a href="#3-1-1定义" class="headerlink" title="3.1.1定义"></a>3.1.1定义</h3><p>一个函数输入一个三维向量，输出一个三维向量。称作为线性变换。</p>
<h3 id="3-1-2矩阵表示"><a href="#3-1-2矩阵表示" class="headerlink" title="3.1.2矩阵表示"></a>3.1.2矩阵表示</h3><p>参考线性代数</p>
<h3 id="3-1-3缩放"><a href="#3-1-3缩放" class="headerlink" title="3.1.3缩放"></a>3.1.3缩放</h3><p>如图</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-15.png"></p>
<p>左侧是原始目标，中间的是Y轴缩放，最右侧是X轴缩放</p>
<p>通过下面的式子来定义缩放变换：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-18.png" alt="S(x, y, z) = (sxx, syy, szz) "></p>
<p>缩放变换是相对于坐标原点的，按照三个轴上的单位向量进行。</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-17.png" alt=".o,sz .O) = 
.l,sz 
y o,sz 
s(k) "></p>
<p>换成矩阵表示就是</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-16.png" alt="s 
O 
0 
o 
o 
o "></p>
<p>我们称这个矩阵是缩放矩阵</p>
<p>该矩阵的逆矩阵为</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-19.png" alt="l/sx "></p>
<p>举个例子：</p>
<p>假设目前有一个矩形，左下角点为（-4，-4，0），右上角为（4，4，0），是一个位于xoy面上的正方形。对该矩形在x轴上缩放0.5个单位，在y轴缩放2.0个单位，z轴不变，对应的缩放矩阵是：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-20.png" alt="0.5 
o "></p>
<p>对两个点进行缩放运算</p>
<p>![0.5<br>[-4,궈,이 0<br>0<br>0<br>2<br>0<br>0<br>0 =[-2,-8,0] [4,4,0]<br>0.5<br>0<br>0<br>0<br>0<br>20 =<a target="_blank" rel="noopener" href="https://www.muchenhen.com/wp-content/uploads/2019/10/image-21.png">2,8,이<br>0<br>1 </a></p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-22.png" alt="Scaling: 
(4, 4,0) 
-8,0) "></p>
<h3 id="3-1-4旋转"><a href="#3-1-4旋转" class="headerlink" title="3.1.4旋转"></a>3.1.4旋转</h3><p>在这个部分，描述了一个向量v绕着坐标轴n旋转一个θ角。注意，测量的角度是向下看n轴的顺时针方向的角度，假设n的模=1。</p>
<p>旋转的矩阵表示如下：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-23.png" alt="o 
O 
coso 
—sin O 
sin 0 
coso 
coso 
sin O 
o 
O 
—sin O 
coso 
coso 
—sin 0 
sin O 
coso 
o 
o 
1 
o 
o 
o 
o 
1 "></p>
<p>举个例子：</p>
<p>我们定义一个左下角坐标为（-1，0，-1），右上角为（1，0，1）的矩形。要求将其绕Y轴顺时针旋转-30度（即逆时针30度），对应的Y轴旋转矩阵为：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-24.png" alt="coso 
sin O 
o 
O 
—sin O 
coso 
cos( 
sin ( 
-300) 
-300) 
O —sin (—30 ) 
o 
I 
0 "></p>
<p>将举行的两个点坐标与旋转矩阵相乘可以得到：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-25.png"></p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-26.png"></p>
<h2 id="3-2仿射变换"><a href="#3-2仿射变换" class="headerlink" title="3.2仿射变换"></a>3.2仿射变换</h2><p>此部分总结在其他文章</p>
<h2 id="3-3-Composition-of-Transformation"><a href="#3-3-Composition-of-Transformation" class="headerlink" title="3.3 Composition of Transformation"></a>3.3 Composition of Transformation</h2><p>成分转换</p>
<p>假设S是一个缩放矩阵，R是一个旋转矩阵，T是一个位移矩阵。假设有一个cube，是由八个向量Vi所确定的，如果要将三个变换依次应用于每个顶点，最简单的办法是一步一步来。但是由于矩阵乘法有结合律，所以可以简化，求出一个矩阵C，使C满足C=SRT。如下：</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-27.png" alt="for "></p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-28.png" alt="v, (SRT)zv,&quot;&#39; for i "></p>
<p>可以将矩阵C看作三个变换封装的一个净变换矩阵。</p>
<p>这对性能有很重要的影响，比如假设有20000个点的某个对象，不用封装矩阵的话，会需要进行20000*3次的矩阵乘法运算，使用组合之后的矩阵只需要进行20000次。</p>
<p>再次注意：是结合律，绝对是没有交换律的。</p>
<h2 id="3-4坐标变换"><a href="#3-4坐标变换" class="headerlink" title="3.4坐标变换"></a>3.4坐标变换</h2><p>同一个向量在不同的坐标系有不同的相对于坐标系的坐标。计算机图形学中经常使用多个坐标系，所以需要知道如何在坐标系之间转换。位置不是向量的属性，是点的属性，所以坐标系变换是针对点的。</p>
<h2 id="3-5变换矩阵与坐标系变换"><a href="#3-5变换矩阵与坐标系变换" class="headerlink" title="3.5变换矩阵与坐标系变换"></a>3.5变换矩阵与坐标系变换</h2><p>其实在数学上，对一个对象进行的变换（平移，旋转，缩放等）和坐标系的变换是等价的。一个主动的变换可以被视为坐标系转换的变化。</p>
<h2 id="3-6-DIRECTX数学变换函数"><a href="#3-6-DIRECTX数学变换函数" class="headerlink" title="3.6 DIRECTX数学变换函数"></a>3.6 DIRECTX数学变换函数</h2><p>// Constructs a scaling matrix: 构造一个缩放矩阵<br>XMMATRIX XM_CALLCONV XMMatrixScaling( float ScaleX, float ScaleY, float ScaleZ);</p>
<p>// Constructs a scaling matrix from components in vector:从向量中的分量构造一个缩放矩阵<br>XMMATRIX XM_CALLCONV XMMatrixScalingFromVector( FXMVECTOR Scale);</p>
<p>// Constructs a x-axis rotation matrix Rx: 构造一个x轴旋转矩阵，顺时针旋转<br>XMMATRIX XM_CALLCONV XMMatrixRotationX(float Angle);</p>
<p>// Constructs a y-axis rotation matrix Ry: 构造一个y轴旋转矩阵，顺时针<br>XMMATRIX XM_CALLCONV XMMatrixRotationY(float Angle);</p>
<p>// Constructs a z-axis rotation matrix Rz: z轴，顺时针<br>XMMATRIX XM_CALLCONV XMMatrixRotationZ(float Angle);</p>
<p>// Constructs an arbitrary axis rotation matrix Rn: 构造任意轴旋转矩阵，第一个参数是轴所对应的向量，第二个参数是顺时针角度<br>XMMATRIX XM_CALLCONV XMMatrixRotationAxis(FXMVECTOR Axis, float Angle);</p>
<p>//Constructs a translation matrix: 平移矩阵<br>XMMATRIX XM_CALLCONV XMMatrixTranslation( float OffsetX, float OffsetY, float OffsetZ);</p>
<p>//Constructs a translation matrix from components in a vector: 从向量的分量构造平移矩阵<br>XMMATRIX XM_CALLCONV XMMatrixTranslationFromVector( FXMVECTOR Offset);</p>
<p>// Computes the vector-matrix product vM where vw = 1 for transforming points: 计算向量矩阵乘积vM，其中vw = 1表示转换点<br>XMVECTOR XM_CALLCONV XMVector3TransformCoord( FXMVECTOR V, CXMMATRIX M);</p>
<p>// Computes the vector-matrix product vM where vw = 0 for transforming vectors:计算向量矩阵乘积vM，其中vw = 0表示向量的变换<br>XMVECTOR XM_CALLCONV XMVector3TransformNormal( FXMVECTOR V, CXMMATRIX M);</p>
<h2 id="3-7总结"><a href="#3-7总结" class="headerlink" title="3.7总结"></a>3.7总结</h2><p>1、基本变换矩阵——缩放、旋转和平移——由下列形式给出:</p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-29.png"></p>
<p>2、我们用4×4矩阵来表示变换，用1×4齐次坐标来描述点和向量，其中我们通过设置第四个分量为w = 1来表示一个点，通过设置w = 0来表示一个向量。这样，平移作用于点而不是向量。</p>
<p>关于为什么要使用4*4矩阵的原因</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36296104">为什么directX里表示三维坐标要建一个4*4的矩阵？</a></p>
<p>3、如果一个矩阵的所有行向量都是单位长度并且相互正交，那么这个矩阵就是正交的。一个正交矩阵的特殊性质是它的逆等于它的转置，从而使得逆的计算简单而有效。所有的旋转矩阵都是正交的。</p>
<p>4. 根据矩阵乘法的结合律，我们可以将多个变换矩阵合并成一个变换矩阵。</p>
<p>5、如果矩阵M将坐标系A映射到坐标系B中，那么矩阵M的逆矩阵将坐标系B映射到坐标系A中。</p>
<p>6、主动变换可以解释为坐标变换的变化，反之亦然。对于某些情况，更直观的做法是使用多个坐标系统，并在对象保持不变但其坐标表示方式发生变化的系统之间进行转换，因为它是相对于不同的参照系进行描述的。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/30/stl%EF%BC%9Aarray%E5%AE%B9%E5%99%A8/">STL：array容器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><p>需要头文件<br>命名空间为std<br>定义为class template<br>namespace std {<br>template<br>class array;<br>}<br>包覆一个静态c数组并提供了一个STL容器接口。有固定大小，无法增加或者删除，有固定大小。只能改变元素值。<br>第二个参数为生命周期内元素的个数，size()函数 返回值总等于N<br>array会将元素复制到内部的c数组，是有序的，且支持随机访问。内存分配在栈中，绝不会被重新分配</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>array特殊的地方是，默认构造产生的不是空容器，元素数量一定是第二个参数N。初值可能不明确，不一定是0。<br>arrayx;//x内的元素值不确定<br>arrayx1 = {};//x1内的元素都为0 (int())<br>arrayx2 = { 1,2,3,4 };//正常的一个初始化<br>arrayx3 = { 3 };//第一个元素是3，后面的是0<br>如果元素数量超过N值，会出现错误</p>
<p>array的swap操作可以和一个元素类型和元素个数都相同的容器置换彼此的元素，但迭代器和引用不会改变所指 的容器。</p>
<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>array大小可以是0，此时begin()和end()，cbegin()和cend()都会释出同一个值。但是front()和back()返回的就不明确了。</p>
<p>建立赋值和删除操作</p>
<p>操作</p>
<p>结果</p>
<p>array&lt;Elem,N&gt; c</p>
<p>某人构造，有默认参数表</p>
<p>array&lt;Elem,N&gt; c(c2)</p>
<p>复制构造，建立另一个同类型array并复制所有元素</p>
<p>array&lt;Elem,N&gt; c = c2</p>
<p>同上</p>
<p>array&lt;Elem,N&gt; c = initlist</p>
<p>给初始化参数列来建立一个array</p>
<h2 id="非变动性操作"><a href="#非变动性操作" class="headerlink" title="非变动性操作"></a>非变动性操作</h2><p>操作</p>
<p>结果</p>
<p>c.empty()</p>
<p>返回是否为空</p>
<p>c.size()</p>
<p>返回目前的元素个数，都是N</p>
<p>c.max_size()</p>
<p>返回元素个数的可能最大值</p>
<p>==</p>
<p>对每个元素调用了==</p>
<p>!=</p>
<p>相当于!(==)</p>
<p>&lt;</p>
<p> </p>
<p>&gt;</p>
<p> </p>
<p>&lt;=</p>
<p>相当于!(&lt;)</p>
<p>&gt;=</p>
<p>相当于!(&gt;)</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>除了赋值操作符之外，只能用fill()赋新值给每一个元素</p>
<p>操作</p>
<p>结果</p>
<p>c = c2</p>
<p>将c2元素给c</p>
<p>c.fill(value)</p>
<p>将value的值赋给c中的每一个元素</p>
<p>c1.swap(c2)</p>
<p>置换c1和c2的数据</p>
<p>swap(c1.c2)</p>
<p>同上，此函数是全局函数</p>
<h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>访问array内的所有元素，需要使用范围for循环，或者特定操作函数或迭代器。</p>
<p>也可以像c数组一样，第一个元素索引是0，最后一个是size()-1.</p>
<p>操作</p>
<p>结果</p>
<p>c[index]</p>
<p>返回索引所指向的元素，不检查范围</p>
<p>c.at(index)</p>
<p>返回索引指向的元素，会检查范围，超过范围抛出范围错误异常</p>
<p>c.front()</p>
<p>返回第一个元素，不检查是否存在第一个元素</p>
<p>c.back()</p>
<p>返回最后一个元素，不检查是否存在最后一个</p>
<h2 id="迭代器相关函数"><a href="#迭代器相关函数" class="headerlink" title="迭代器相关函数"></a>迭代器相关函数</h2><p>array提供的是随机访问迭代器，原则上对array可以用STL的所有算法</p>
<p>操作</p>
<p>效果</p>
<p>c.begin()</p>
<p>返回迭代器指向第一个元素</p>
<p>c.end()</p>
<p>指向最后一个</p>
<p>c.cbegin()</p>
<p>返回一个const迭代器指向第一个，c11</p>
<p>c.cend()</p>
<p>只想最后一个的const迭代器,c11</p>
<p>c.rbegin()</p>
<p>返回一个反向的迭代器指向第一个元素</p>
<p>c.rend()</p>
<p>返回一个反向的迭代器指向最后一个元素</p>
<p>c.crbegin()</p>
<p>返回一个const反向指向第一个的迭代器,c11</p>
<p>c.crend()</p>
<p>返回一个const反向指向最后一个的迭代器,c11</p>
<p>对于array来说，begin(),end(),cbegin(),cend()返回的是普通指针。并且只要array有效，其迭代器也保持有效，并且swap()函数是将新值赋给迭代器、引用、指针指向的元素上。</p>
<h2 id="Tuple接口"><a href="#Tuple接口" class="headerlink" title="Tuple接口"></a>Tuple接口</h2><p>array提供tuple接口</p>
<p> typedef array FiveStrings;<br>     FiveStrings a = { “h”,”e”,”l”,”l”,”o” };<br>     cout&lt;&lt; tuple_size::value;//取得元素个数<br>     tuple_element&lt;1,FiveStrings&gt;::type;//获取特定的元素类型<br>     get&lt;1&gt;(a);//取得某特定元素</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include “print.h”</p>
<p>int main()<br>{<br>    array a = { 11,22,33,44 };</p>
<pre><code>print(a);
a.back() = 999999;
a\[a.size() - 2\] = 42;
print(a);

cout &lt;&lt; &quot;sum: &quot; &lt;&lt; accumulate(a.begin(), a.end(), 0);

transform(a.begin(), a.end(), a.begin(), negate());
print(a);
</code></pre>
<p>}</p>
<p><img src="http://www.muchenhen.com/wp-content/uploads/2019/10/array.png" alt="11 22 33 44000000 
11 22 33 4400 0 0 42 999999 
sum: 1000151-11 -22 -33 -44 0 0 0 0 
—999999 "></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/dx12%E9%BE%99%E4%B9%A6part%E2%85%A0chapter-2-%E7%9F%A9%E9%98%B5/">DX12龙书PartⅠChapter 2 矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/">d3d</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/d3d/DirectX12/">DirectX12</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DirectX/">DirectX</a></span><div class="content"><p>在三维计算机图形学中，我们使用矩阵来简洁地描述几何变换，如缩放、旋转、平移，以及将点或向量的坐标从一帧变换到另一帧。本章探讨矩阵的数学。</p>
<p>目的:</p>
<ol>
<li> 了解矩阵及其运算。</li>
<li> 发现向量矩阵乘法如何被视为一个线性组合。</li>
<li> 学习单位矩阵是什么，矩阵的转置，行列式和逆是什么。</li>
<li> 熟悉用于矩阵数学的DirectX数学库提供的类和函数的子集。</li>
</ol>
<p>2.1定义</p>
<p>2.2矩阵乘法</p>
<p>2.3矩阵转置</p>
<p>2.4单位矩阵</p>
<p>2.5矩阵行列式</p>
<p>2.6伴随矩阵</p>
<p>2.7矩阵的逆</p>
<h2 id="以上内容为线性代数知识，不赘述"><a href="#以上内容为线性代数知识，不赘述" class="headerlink" title="以上内容为线性代数知识，不赘述"></a>以上内容为线性代数知识，不赘述</h2><h2 id="2-8-DIRECTX-MATH-MATRICES"><a href="#2-8-DIRECTX-MATH-MATRICES" class="headerlink" title="2.8 DIRECTX MATH MATRICES"></a><strong>2.8 DIRECTX MATH MATRICES</strong></h2><p>DirectX数学矩阵</p>
<h2 id="2-8-1矩阵类型"><a href="#2-8-1矩阵类型" class="headerlink" title="2.8.1矩阵类型"></a><strong>2.8.1矩阵类型</strong></h2><p>为了在DirectX数学中表示4×4矩阵，我们使用了XMMATRIX类，它在DirectXMath.h头文件中定义</p>
<p>XMMATRIX使用四个XMVECTOR实例来使用SIMD。而且，XMMATRIX为矩阵运算提供了重载的运算符。</p>
<p>除了使用各种构造函数之外，还可以使用XMMatrixSet函数创建XMMATRIX实例:</p>
<p>XMMATRIX XM_CALLCONV XMMatrixSet(</p>
<p>float m00, float m01, float m02, float m03,</p>
<p>float m10, float m11, float m12, float m13,</p>
<p>float m20, float m21, float m22, float m23,</p>
<p>float m30, float m31, float m32, float m33);</p>
<p>我们使用以下方法将数据从XMFLOAT4X4加载到XMMATRIX:</p>
<p> inline XMMATRIX XM_CALLCONV</p>
<p>XMLoadFloat4x4(const XMFLOAT4X4* pSource);</p>
<p>我们使用以下方法将数据从XMMATRIX存储到XMFLOAT4X4:</p>
<p>inline void XM_CALLCONV</p>
<p>XMStoreFloat4x4(XMFLOAT4X4* pDestination, FXMMATRIX M);</p>
<h2 id="2-8-2矩阵函数"><a href="#2-8-2矩阵函数" class="headerlink" title="2.8.2矩阵函数"></a><strong>2.8.2矩阵函数</strong></h2><p>XMMATRIX XM_CALLCONV XMMatrixIdentity();</p>
<p> // Returns the identity matrix I 返回单位矩阵I</p>
<p> bool XM_CALLCONV XMMatrixIsIdentity( FXMMATRIX M);</p>
<p> // Returns true if M is the identity matrix 如果是单位矩阵返回true</p>
<p> // Input M</p>
<p>XMMATRIX XM_CALLCONV XMMatrixMultiply( FXMMATRIX A, CXMMATRIX B);</p>
<p> // Returns the matrix product AB 返回矩阵AB的乘积</p>
<p>// Input A</p>
<p> // Input B</p>
<p>XMMATRIX XM_CALLCONV XMMatrixTranspose( FXMMATRIX M);</p>
<p>// Returns MT 返回矩阵转置</p>
<p> // Input M</p>
<p>XMVECTOR XM_CALLCONV XMMatrixDeterminant(  FXMMATRIX M);</p>
<p>// Returns(det M, det M, det M, det M) 返回矩阵行列式</p>
<p>// Input M XMMATRIX XM_CALLCONV</p>
<p>XMMatrixInverse(XMVECTOR* pDeterminant, FXMMATRIX M);</p>
<p> // Returns M−1 返回矩阵的逆</p>
<p> // Input (det M, det M, det M, det M)</p>
<p>// Input M</p>
<p>When we declare a XMMATRIX</p>
<h2 id="2-8-3例子"><a href="#2-8-3例子" class="headerlink" title="2.8.3例子"></a><strong>2.8.3例子</strong></h2><p>#include // for XMVerifyCPUSupport<br>#include #include #include using namespace std;<br>using namespace DirectX;<br>using namespace DirectX::PackedVector;</p>
<p>// Overload the  “&lt;&lt;” operators so that we can use cout to<br>//重载“&lt;&lt;”操作符，以便我们可以使用cout<br>// output XMVECTOR and XMMATRIX objects.<br>//输出XMVECTOR和XMMATRIX对象。<br>ostream&amp; XM_CALLCONV operator &lt;&lt; (ostream&amp; os, FXMVECTOR v)<br>{<br>    XMFLOAT4 dest;<br>    XMStoreFloat4(&amp;dest, v);</p>
<pre><code>os &lt;&lt; &quot;(&quot; &lt;&lt; dest.x &lt;&lt; &quot;, &quot; &lt;&lt; dest.y &lt;&lt; &quot;, &quot; &lt;&lt; dest.z &lt;&lt; &quot;, &quot; &lt;&lt; dest.w &lt;&lt; &quot;)&quot;;
return os;
</code></pre>
<p>}</p>
<p>ostream&amp; XM_CALLCONV operator &lt;&lt; (ostream&amp; os, FXMMATRIX m)<br>{<br>    for (int i = 0; i &lt; 4; ++i)<br>    {<br>        os &lt;&lt; XMVectorGetX(m.r[i]) &lt;&lt; “\t”;<br>        os &lt;&lt; XMVectorGetY(m.r[i]) &lt;&lt; “\t”;<br>        os &lt;&lt; XMVectorGetZ(m.r[i]) &lt;&lt; “\t”;<br>        os &lt;&lt; XMVectorGetW(m.r[i]);<br>        os &lt;&lt; endl;<br>    }<br>    return os;<br>}</p>
<p>int main()<br>{<br>    // Check support for SSE2 (Pentium4, AMD K8, and above).<br>    //检查是否支持SSE2<br>    if (!XMVerifyCPUSupport())<br>    {<br>        cout &lt;&lt; “directx math not supported” &lt;&lt; endl;<br>        return 0;<br>    }</p>
<pre><code>XMMATRIX A(1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 2.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 4.0f, 0.0f,
    1.0f, 2.0f, 3.0f, 1.0f);

XMMATRIX B = XMMatrixIdentity();//定义了一个单位矩阵

XMMATRIX C = A \* B;//矩阵乘法

XMMATRIX D = XMMatrixTranspose(A);//A的转置

XMVECTOR det = XMMatrixDeterminant(A);//A的行列式
XMMATRIX E = XMMatrixInverse(&amp;det, A);//A的逆

XMMATRIX F = A \* E;//A乘A的逆矩阵，结果是单位阵

cout &lt;&lt; &quot;A = &quot; &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;B = &quot; &lt;&lt; endl &lt;&lt; B &lt;&lt; endl;
cout &lt;&lt; &quot;C = A\*B = &quot; &lt;&lt; endl &lt;&lt; C &lt;&lt; endl;
cout &lt;&lt; &quot;D = transpose(A) = &quot; &lt;&lt; endl &lt;&lt; D &lt;&lt; endl;
cout &lt;&lt; &quot;det = determinant(A) = &quot; &lt;&lt; det &lt;&lt; endl &lt;&lt; endl;
cout &lt;&lt; &quot;E = inverse(A) = &quot; &lt;&lt; endl &lt;&lt; E &lt;&lt; endl;
cout &lt;&lt; &quot;F = A\*E = &quot; &lt;&lt; endl &lt;&lt; F &lt;&lt; endl;

return 0;
</code></pre>
<p>} </p>
<p><img src="https://www.muchenhen.com/wp-content/uploads/2019/10/image-14.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/latex%E6%B5%8B%E8%AF%95/">Latex测试</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/uncategorized/">uncategorized</a></span><div class="content"><p>$latex i\hbar\frac{\partial}{\partial t}\left|\Psi(t)\right&gt;=H\left|\Psi(t)\right&gt;&amp;bg=202020&amp;fg=ffffff&amp;s=4$</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/stl%E5%AE%B9%E5%99%A8%E5%85%B1%E9%80%9A%E6%93%8D%E4%BD%9C/">STL容器共通操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/">cpp</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cpp/STL/">STL</a></span><div class="content"><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>每个容器都提供默认构造函数，拷贝构造函数，析构函数。</p>
<p><strong>初值列</strong></p>
<p>可以以一个区间或者初值列作为容器初值。</p>
<p>比如常量容器的初始化：</p>
<p>//用初始值初始化一个vector（c++11）<br>const vector<int> v1 = {1, 2, 3, 4 };<br>//也可用不同的语法<br>const vector<int> v2 {1, 2, 3, 4 };</p>
<p>array&lt;&gt;容器使用初值列有特殊规则。将会在array容器中解释。</p>
<p>以某个给定区间初始化的构造函数，参数可以是来自另一个容器、来自c风格的数组、标准输入的元素。可以是不同容器，不同元素类型，前提是来源和目标的元素类型可以自动转换</p>
<p>//int元素的list容器<br>listl;<br>//拷贝构造给一个float的vector容器<br>vectorc(l.begin(), l.end());<br>//c++11也可以使用move迭代器来搬移所有元素<br>vectorc2(make_move_iterator(l.begin()), make_move_iterator(l.end()));<br>//用c风格数组完成初始化<br>int carray[] = { 1,2,3,4 };<br>setc3(begin(carray), end(carray));//c++11中iterator定义了begin和end两个函数<br>//以标准输入设备完成初始化动作<br>deque c5{ istream_iterator(cin),istream_iterator() };<br>//c++11中可以使用一个move构造函数将容器初始化<br>vectorv1;<br>vectorv2 = move(v1);//新建容器会有之前的值，被当作初值的容器内容会不明确<br>                         //因为move函数是调动指针，不是逐一复制元素，效率较高<br>                         //在不需要某个容器又需要复制时使用move </p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h2><p>用来置换两个容器的内容，事实上知识只换了若干内部的指针，可以保证常数时间复杂度。执行之后原本存在的迭代器和引用都指向原先所指的元素，不过这些元素已经位于另一个容器中了</p>
<p>array&lt;&gt;容器的该函数行为略有不同。因为此容器无法只在内部置换指针，所以array&lt;&gt;的swap()是线性时间复杂度，而且操作之后原本存在的迭代器和引用指向同一容器中的不同元素。</p>
<h2 id="大小相关的操作函数"><a href="#大小相关的操作函数" class="headerlink" title="大小相关的操作函数"></a>大小相关的操作函数</h2><p>所有容器都提供三个与大小相关的操作函数</p>
<p>**empty()**：是size()==0同义快速形式，一般比后者效率高。</p>
<p>**size()**：返回当前容器的元素个数。</p>
<p>**max_size()**：返回容器所能容纳的元素个数的最大值。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>除了无序容器之外，常用的比较操作符==,!=,&lt;,&lt;=,&gt;,&gt;=都依据以下三个规则定义：</p>
<p>比较的两个容器必须属于同一类型</p>
<p>如果两个容器的元素全部依序相等，则这两个容器相等</p>
<p>无序容器只定义了==,!=</p>
<p>两个容器内的每一个元素都在另一个容器有相等元素，==就返回true，元素次序无关紧要。</p>
<p>如果要比较两个容器，必须使用STL比较算法</p>
<h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>所有容器都支持基于范围的for循环</p>
<p>c++11中常用的容器访问操作</p>
<pre><code>//定义一个vector容器
vectornums = &#123; 1,2,3,4,5,6 &#125;;
//访问每个元素并输出
for (const auto&amp; elem : nums)
&#123;
    cout &lt;&lt; elem &lt;&lt; &quot; &quot;;
&#125;
//如果要改变元素就不写const
for (auto&amp; elem : nums)
&#123;
    elem = 0;
&#125;
//对指定位置进行插入删除等操作,可以使用cbegin()和cend()产生的只读迭代器
for (auto pos = nums.cbegin(); pos != nums.cend(); ++pos)
&#123;
    cout &lt;&lt; \*pos &lt;&lt; endl;
&#125;
//使用begin()和end()产生的迭代器进行修改
for (auto pos = nums.begin(); pos != nums.end(); pos++)
&#123;
    \*pos = 0;
&#125; 
</code></pre>
<h2 id="常见容器类共通操作表"><a href="#常见容器类共通操作表" class="headerlink" title="常见容器类共通操作表"></a>常见容器类共通操作表</h2><p>操作</p>
<p>必要</p>
<p>效果</p>
<p>ContType c</p>
<p>1</p>
<p>默认构造函数,建立一个空容器，array会有默认元素</p>
<p>ContType c(c2)</p>
<p>1</p>
<p>拷贝构造</p>
<p>ContTypr c = c2</p>
<p>1</p>
<p>拷贝构造</p>
<p>ContType c(begin,end)</p>
<p> </p>
<p>以区间内所有元素拷贝</p>
<p>ContType c(initlist)</p>
<p> </p>
<p>以初值列为初值，不适用于array，c++11</p>
<p>ContType c = initlist</p>
<p> </p>
<p>同上，但适用于array</p>
<p>c.~ContType()</p>
<p>1</p>
<p>删除所有元素并释放内存</p>
<p>c.empty()</p>
<p>1</p>
<p>判断容器是否为空</p>
<p>c.size()</p>
<p>1</p>
<p>返回容器中元素数量</p>
<p>c.max_size()</p>
<p>1</p>
<p>返回元素数量可能的最大值</p>
<p>c1 == c2</p>
<p>1</p>
<p>判断两个容器是否相等</p>
<p>c1 != c2</p>
<p>1</p>
<p>判断是否不等</p>
<p>&gt;,&lt;,&gt;=,&lt;=</p>
<p> </p>
<p>不适用于无序容器</p>
<p>c = c2</p>
<p>1</p>
<p>c2所有元素值赋给c</p>
<p>c1.swap(c2)</p>
<p>1</p>
<p>置换c1和c2的数据</p>
<p>swap(c1,c2)</p>
<p>1</p>
<p>同上，但是个全局函数</p>
<p>c.begin()</p>
<p>1</p>
<p>返回指向第一个元素的迭代器</p>
<p>c.end()</p>
<p>1</p>
<p>返回指向最后一个元素的下一个位置的迭代器</p>
<p>c.cbegin()</p>
<p>1</p>
<p>返回一个const迭代器，指向第一个元素，c++11</p>
<p>c.cend()</p>
<p>1</p>
<p>返回一个const迭代器，指向最后一个元素的下一个位置，c++11</p>
<p>c.clear()</p>
<p> </p>
<p>移除所有元素，令容器为空，不适用于array</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By 木尘痕</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">天道作何，吞恨者多 <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">豫ICP备17048032号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>