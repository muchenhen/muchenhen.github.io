<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="放一些笔记的地方"><meta name="keywords" content=""><meta name="author" content="木尘痕"><meta name="copyright" content="木尘痕"><title>一点浩然气 千里快哉风 | 风生之谷</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/muchenhen/muchenhen.github.io/master/xuange.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://github.com/muchenhen/muchenhen.github.io/blob/master/XuanGe.jpg?raw=true"></div><div class="author-info__name text-center">木尘痕</div><div class="author-info__description text-center">放一些笔记的地方</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">172</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://alec-ray.github.io/">止戈</a></div></div></div><nav id="nav" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">风生之谷</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">全部文章</a><a class="site-page" href="/tags">标签分类</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/contact">联系</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">风生之谷</div><div id="site-sub-title">一点浩然气 千里快哉风</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/%E4%BA%8C%E5%88%86%E4%BE%8B%E9%A2%98%EF%BC%9Aaggressive-cows/">二分例题：Aggressive cows</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>总时间限制: 1000ms</p>
<p>内存限制: 65536kB</p>
<p><strong>描述</strong></p>
<p>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p>
<p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p>
<p><strong>输入</strong></p>
<p>* Line 1: Two space-separated integers: N and C</p>
<p>* Lines 2..N+1: Line i+1 contains an integer stall location, xi</p>
<p><strong>输出</strong></p>
<p>* Line 1: One integer: the largest minimum distance</p>
<p><strong>样例输入</strong></p>
<p>5 3<br>1<br>2<br>8<br>4<br>9</p>
<p><strong>样例输出</strong></p>
<p>3</p>
<p><strong>提示</strong></p>
<p>OUTPUT DETAILS:</p>
<p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p>
<p>Huge input data,scanf is recommended.</p>
<p><strong>来源</strong></p>
<p>USACO 2005 February Gold</p>
<p>来自 &lt;<a target="_blank" rel="noopener" href="http://cxsjsxmooc.openjudge.cn/2018t2fallw4/1/">http://cxsjsxmooc.openjudge.cn/2018t2fallw4/1/</a>&gt;</p>
<p>农夫 John 建造了一座很长的畜栏，它包括N (2≤N≤100,000)个隔间，这 些小隔间的位置为x0 ,…,xN-1 (0≤xi≤1,000,000,000,均为整数,各不相同). John的C (2≤C≤N)头牛每头分到一个隔间。牛都希望互相离得远点省得互 相打扰。怎样才能使任意两头牛之间的最小距离尽可能的大，这个最大的 最小距离是多少呢？</p>
<p>解法1： 先得到排序后的隔间坐标 x0 ,…,xN-1 从1,000,000,000到1依次尝试这个 “最大的最近距离”D，找到的 第一个可行的就是答案。 尝试方法： 1) 第1头牛放在x0 2) 若第k头牛放在xi ，则找到xi+1到xN-1中第一个位于[xi+D, 1,000,000,000]中的Xj ,第k+1头牛放在Xj。找不到这样的Xj ,则 D=D-1,转 1)再试 若所有牛都能放下，则D即答案</p>
<p>复杂度 1,000,000,000/C *N，即 1,000,000,000, 超时</p>
<p>解法2： 先得到排序后的隔间坐标 x0 ,…,xN-1 在[L,R]内用二分法尝试“最大最近距离”D = (L+R)/2 (L,R初值为 [1, 1,000,000,000/C] 若D可行，则记住该D，然后在新[L,R]中继续尝试(L= D+1) 若D不可行，则在新[L,R]中继续尝试(R= D-1) 复杂度 log(1,000,000,000/C) * N</p>
<p>#include #include #include #include #include using namespace std;</p>
<p>int a[100005];<br>int n, m;<br>int f(int mid)    //查找距离为mid时的个数<br>{<br>    int sum = 0;<br>    int len = 1;<br>    for (int i = 1; i &lt; n; i++)<br>    {<br>        if ((sum + (a[i] - a[i - 1])) &lt; mid)<br>        {<br>            sum += (a[i] - a[i - 1]);<br>        }<br>        else<br>        {<br>            sum = 0;<br>            len++;<br>        }<br>    }<br>    if (len &lt; m) return false;<br>    else return true;<br>}</p>
<p>int main()<br>{<br>    int i;<br>    while (scanf_s(“%d%d”, &amp;n, &amp;m) == 2)<br>    {</p>
<pre><code>    for (i = 0; i &lt; n; i++)
    &#123;
        scanf\_s(&quot;%d&quot;, &amp;a\[i\]);
    &#125;
    sort(a, a + n);
    int low = a\[n - 1\] - a\[0\], high = a\[n - 1\] - a\[0\];
    for (i = 1; i &lt; n; i++)
    &#123;
        low = min(low, a\[i\] - a\[i - 1\]);
    &#125;
    int mid;
    while (low &lt;= high)
    &#123;
        mid = (low + high) / 2;
        if (f(mid))
        &#123;
            low = mid + 1;
        &#125;
        else
        &#123;
            high = mid - 1;
        &#125;
    &#125;
    printf(&quot;%d\\n&quot;, high);
&#125;
return 0;
</code></pre>
<p>}</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/%E4%BA%8C%E5%88%86%E4%BE%8B%E9%A2%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%8C%87%E5%AE%9A%E5%92%8C%E7%9A%84%E6%95%B4%E6%95%B0%E5%AF%B9/">二分例题：寻找指定和的整数对</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>输入n ( n&lt;= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯 定有解)。题中所有整数都能用 int 表示</p>
<p>解法1：用两重循环，枚举所有的取数方法，复杂度是O(n2 )的</p>
<p>for(int i = 0;i &lt; n-1; ++i)<br>    for(int j = i + 1; j &lt; n; ++j)<br>        if( a[i]+a[j] == m)<br>break;</p>
<p>100,0002 = 100亿，在各种OJ上提交或参加各种程序设计竞赛，这样的复杂度都会超时</p>
<p>解法2： 1) 将数组排序，复杂度是O(n×log(n)) 2) 对数组中的每个元素a[i],在数组中二分查找m-a[i]，看能否找到。复杂度log(n)，最 坏要查找n-2次，所以查找这部分的复杂度也是O(n×log(n)) 这种解法总的复杂度是O(n×log(n))的。</p>
<p>解法3： 1) 将数组排序，复杂度是O(n×log(n)) 2) 查找的时候，设置两个变量i和j,i初值是0,j初值是n-1.看a[i]+a[j],如果大于m，就让j 减1，如果小于m,就让i加1，直至a[i]+a[j]=m。 这种解法总的复杂度是O(n×log(n))的。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%9A%84%E6%A0%B9/">二分法求方程的根</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>求下面方程的一个根：f(x) = x3 -5x2+10x-80 = 0 若求出的根是a，则要求 |f(a)| &lt;= 10-6</p>
<p>解法：对f(x)求导，得f’(x)=3x2-10x+10。由一元二次方程求根公式知方程 f’(x)= 0 无解，因此f’(x)恒大于0。故f(x)是单调递增的。易知 f(0) &lt; 0且 f(100)&gt;0,所以区间[0,100]内必然有且只有一个根。由于f(x)在[0,100]内是单 调的，所以可以用二分的办法在区间[0,100]中寻找根。</p>
<p>#include<br>#include<br>#include<br>using namespace std;<br>double EPS = 1e-6;<br>double f(double x) { return x * x*x - 5 * x*x + 10 * x - 80; }<br>int main() {<br>    double root, x1 = 0, x2 = 100, y;<br>    root = x1 + (x2 - x1) / 2;<br>    int triedTimes = 1; //记录一共尝试多少次，对求根来说不是必须的<br>    y = f(root);<br>    while (fabs(y) &gt; EPS) {<br>        if (y &gt; 0) x2 = root;<br>        else x1 = root;<br>        root = x1 + (x2 - x1) / 2;<br>        y = f(root);<br>        triedTimes++;<br>    }<br>    printf(“%.8f\n”, root);<br>    printf(“%d”, triedTimes);<br>    return 0;<br>}</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>A心里想一个1-1000之间的数，B来猜，可以问问题，A只能回答是或否。怎 么猜才能问的问题次数最少？ 是1吗？是2吗？…….是999吗？ 平均要问500次 大于500吗？大于750吗？大于625吗？ ……每次缩小猜测范围到上次的一半， 只需要 10次</p>
<p>写一个函数BinarySeach，在包含size个元素的、从小到大排序的int数组a里查找元素 p,如果找到，则返回元素下标，如果找不到，则返回-1。要求复杂度O(log(n))</p>
<p>int BinarySearch(int a[], int size, int p)<br>{<br>    int L = 0; //查找区间的左端点<br>    int R = size - 1; //查找区间的右端点<br>    while (L &lt;= R) { //如果查找区间不为空就继续查找<br>        int mid = L + (R - L) / 2; //取查找区间正中元素的下标<br>        if (p == a[mid])<br>            return mid;<br>        else if (p &gt; a[mid])<br>            L = mid + 1; //设置新的查找区间的左端点<br>        else<br>            R = mid - 1; //设置新的查找区间的右端点<br>    }<br>    return -1;<br>} //复杂度O(log(n))</p>
<p>写一个函数LowerBound，在包含size个元素的、从小到大排序的int数组a里查找比给 定整数p小的，下标最大的元素。找到则返回其下标，找不到则返回-1</p>
<p>int LowerBound(int a[], int size, int p) //复杂度O(log(n))<br>{<br>    int L = 0; //查找区间的左端点<br>    int R = size - 1; //查找区间的右端点<br>    int lastPos = -1; //到目前为止找到的最优解<br>    while (L &lt;= R) { //如果查找区间不为空就继续查找<br>        int mid = L + (R - L) / 2; //取查找区间正中元素的下标<br>        if (a[mid] &gt;= p)<br>            R = mid - 1;<br>        else {<br>            lastPos = mid;<br>            L = mid + 1;<br>        }<br>    }<br>    return lastPos;<br>}</p>
<p>注意： int mid = (L+R)/2; //取查找区间正中元素的下标</p>
<p>为了防止 (L+R)过大溢出: int mid = L+(R-L)/2;</p>
<p>二分查找的前提是已经被排过序</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/%E7%A8%8B%E5%BA%8F%E6%88%96%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">程序或算法的时间复杂度</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>一个程序或算法的时间效率，也称“时间复杂度”，有时简称“复杂度”</p>
<p>复杂度常用大的字母O和小写字母n来表示，比如O(n),O(n2 )等。n代表问题 的规模</p>
<p>时间复杂度是用算法运行过程中，某种时间固定的操作需要被执行的次数和n 的关系来度量的。在无序数列中查找某个数，复杂度是O(n)</p>
<p>计算复杂度的时候，只统计执行次数最多的(n足够大时)那种固定操作的次数 。比如某个算法需要执行加法n2次，除法n次，那么就记其复杂度是O(n2 )的。</p>
<p>如果复杂度是多个n的函数之和，则只关心随n的增长增长得最快的那个函数</p>
<p>O(n3+n2 ) =&gt; O(n3 )</p>
<p>O(2n+n3 ) =&gt; O(2n )</p>
<p>O(n! + 3n ) =&gt; O(n!)</p>
<p>常数复杂度：O(1) 时间(操作次数)和问题的规模无关</p>
<p>对数复杂度：O(log(n))</p>
<p>线性复杂度：O(n)</p>
<p>多项式复杂度：O(nk )</p>
<p>指数复杂度：O(an )</p>
<p>阶乘复杂度：O(n! )</p>
<p>复杂度有“平均复杂度”和“最坏复杂度”两种。 两者可能一致，也可能不一致</p>
<p>在无序数列中查找某个数(顺序查找) O(n)</p>
<p>平面上有n个点，要求出任意两点之间的距离 O(n2 )</p>
<p>插入排序、选择排序、冒泡排序 O(n2 )</p>
<p>快速排序 O( n*log(n))</p>
<p>二分查找 O(log(n))</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9A160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">LeetCode题解：160. 相交链表</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><div class="content"><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>例如，下面的两个链表：<br>A: a1 → a2<br>                    ↘<br>                         c1 → c2 → c3<br>                     ↗<br>B: b1 → b2 → b3</p>
<p>在节点 c1 开始相交。</p>
<p>注意：<br>• 如果两个链表没有交点，返回 null.<br>• 在返回结果后，两个链表仍须保持原有的结构。<br>• 可假定整个链表结构中没有循环。<br>• 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<p>来自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/</a></p>
<p>/**<br> * Definition for singly-linked list.<br> * struct ListNode {<br> *     int val;<br> *     ListNode *next;<br> *     ListNode(int x) : val(x), next(NULL) {}<br> * };<br> */<br>class Solution {<br>public:<br>   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB){<br>    if(!headA || !headB)<br>        return NULL;<br>    int lenA= getLength(headA),lenB=getLength(headB);<br>    if(lenAnext;<br>    }<br>    else<br>    {<br>        for (int i = 0; i &lt; lenA-lenB; i++)<br>            headA=headA-&gt;next;<br>    }<br>    while (headA &amp;&amp; headB &amp;&amp; headA!=headB )<br>    {<br>        headA=headA-&gt;next;<br>        headB=headB-&gt;next;<br>    }<br>    return headA&amp;&amp;headB?headA:NULL;<br>}</p>
<p>int getLength(ListNode *head){<br>    int cnt=0;<br>        while (head) {<br>            ++cnt;<br>            head = head-&gt;next;<br>        }<br>        return cnt;<br>}<br>};</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9A142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/">LeetCode题解：142. 环形链表 II</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><div class="content"><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<p>你是否可以不用额外空间解决此题？</p>
<p>来自 &lt;<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/">https://leetcode-cn.com/problems/linked-list-cycle-ii/description/</a>&gt;</p>
<p>/**<br> * Definition for singly-linked list.<br> * struct ListNode {<br> *     int val;<br> *     ListNode *next;<br> *     ListNode(int x) : val(x), next(NULL) {}<br> * };<br> */<br>class Solution {<br>public:<br>   ListNode *detectCycle(ListNode *head) {<br>        ListNode *slow = head, *fast = head;<br>        while (fast &amp;&amp; fast-&gt;next) {<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            if (slow == fast) break;<br>        }<br>        if (!fast || !fast-&gt;next) return NULL;<br>        slow = head;<br>        while (slow != fast) {<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        }<br>        return fast;<br>    }<br>};</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/leetcode%E9%A2%98%E8%A7%A3141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">LeetCode题解：141. 环形链表</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><div class="content"><p>给定一个链表，判断链表中是否有环。</p>
<p><strong>进阶：</strong></p>
<p>你能否不使用额外空间解决此题？</p>
<p>来自 &lt;<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/description/">https://leetcode-cn.com/problems/linked-list-cycle/description/</a>&gt;</p>
<p>/**<br> * Definition for singly-linked list.<br> * struct ListNode {<br> *     int val;<br> *     ListNode *next;<br> *     ListNode(int x) : val(x), next(NULL) {}<br> * };<br> */<br>class Solution {<br>public:<br>    bool hasCycle(ListNode *head){<br>    ListNode *fast=head,*slow=head;<br>    while (fast &amp;&amp; fast-&gt;next)<br>    {<br>        slow=slow-&gt;next;<br>        fast=fast-&gt;next-&gt;next;<br>        if (fast==slow)<br>            return true;<br>    }<br>    return false;<br>}<br>};</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9A217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">LeetCode题解：217. 存在重复元素</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><div class="content"><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<p>来自 &lt;<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/description/">https://leetcode-cn.com/problems/contains-duplicate/description/</a>&gt;</p>
<p>class Solution {<br>public:<br>    bool containsDuplicate(vector&amp; nums) {<br>        int temp=0;<br>        int len=nums.size();<br>        for(int i=0;i</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9A189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">LeetCode题解：189. 旋转数组</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MOOC%E7%AC%94%E8%AE%B0/">MOOC笔记</a></span><div class="content"><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><strong>示例 1:</strong><br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p><strong>示例 2:</strong><br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:<br>• 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>• 要求使用空间复杂度为 O(1) 的原地算法。</p>
<p>来自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/description/">https://leetcode-cn.com/problems/rotate-array/description/</a></p>
<p>class Solution {<br>public:<br>    void rotate(vector&amp; nums, int k) {<br>         int resK = k % nums.size();<br>        int t=0;<br>        for(int i=(nums.size()-resK);it;–j)<br>            {<br>                nums[j] = nums[j-1];<br>            }<br>            nums[t] = record;<br>            t++;<br>        }<br>    }<br>};</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://github.com/muchenhen/muchenhen.github.io/blob/master/FF.png?raw=true)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2021 By 木尘痕</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">天道作何，吞恨者多 <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">豫ICP备17048032号-1</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>